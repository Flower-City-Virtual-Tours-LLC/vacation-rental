"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => {\n  __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\")) {\n    if (part === \"*\") {\n      re.push(\"[^.]+\");\n    } else if (part === \"**\") {\n      re.push(\".*\");\n    } else {\n      re.push(escapeRegExp(part));\n    }\n  }\n  return new RegExp(\"^\".concat(re.join(\".\"), \"$\"));\n}\nclass Path {\n  constructor(pattern) {\n    __publicField$5(this, \"pattern\");\n    __publicField$5(this, \"patternRe\");\n    this.pattern = pattern;\n    this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$4 = (obj, key, value) => {\n  __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass StreamValue {\n  constructor(generator) {\n    __publicField$4(this, \"type\", \"stream\");\n    __publicField$4(this, \"generator\");\n    __publicField$4(this, \"ticker\");\n    __publicField$4(this, \"isDone\");\n    __publicField$4(this, \"data\");\n    this.generator = generator;\n    this.ticker = null;\n    this.isDone = false;\n    this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return true;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this) {\n      result.push(await value.get());\n    }\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i];\n      }\n      if (this.isDone) {\n        return;\n      }\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker) {\n      return this.ticker;\n    }\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve;\n      });\n    };\n    const tick = () => {\n      currentResolver();\n      setupTicker();\n    };\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value);\n        tick();\n      }\n      this.isDone = true;\n      tick();\n    };\n    setupTicker();\n    fetch();\n    return this.ticker;\n  }\n}\n\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str);\n  }\n  return null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4);\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n  const day = addLeadingZero(d.getUTCDate(), 2);\n  const hour = addLeadingZero(d.getUTCHours(), 2);\n  const minute = addLeadingZero(d.getUTCMinutes(), 2);\n  const second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  if (millis != 0) {\n    fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n  }\n  return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  while (str.length < targetLength) {\n    str = \"0\".concat(str);\n  }\n  return str;\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass StaticValue {\n  constructor(data, type) {\n    __publicField$3(this, \"data\");\n    __publicField$3(this, \"type\");\n    this.data = data;\n    this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data)) {\n      return function* (data) {\n        for (const element of data) {\n          yield fromJS(element);\n        }\n      }(this.data);\n    }\n    throw new Error(\"Cannot iterate over: \".concat(this.type));\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    __publicField$3(this, \"date\");\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    if (date) {\n      return new StaticValue(new DateTime(date), \"datetime\");\n    }\n    return NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    copy.setTime(copy.getTime() + secs * 1e3);\n    return new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, \"number\");\n  }\n  return NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value);\n      }\n    });\n  } else if (val === null || val === void 0) {\n    return NULL_VALUE;\n  }\n  return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  if (data === null || typeof data === \"undefined\") {\n    return \"null\";\n  }\n  if (Array.isArray(data)) {\n    return \"array\";\n  }\n  if (data instanceof Path) {\n    return \"path\";\n  }\n  if (data instanceof DateTime) {\n    return \"datetime\";\n  }\n  return typeof data;\n}\n\nfunction isEqual(a, b) {\n  if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n    return a.data === b.data;\n  }\n  if (a.type === \"datetime\" && b.type === \"datetime\") {\n    return a.data.equals(b.data);\n  }\n  return false;\n}\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false;\n  }\n  return patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  const termsRe = matchPatternRegex(text);\n  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n  return terms.map(\n    (term) => new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\"), \"$\"), \"i\")\n  );\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\") {\n    cb(value.data);\n    return true;\n  }\n  if (value.isArray()) {\n    let success = true;\n    for await (const part of value) {\n      if (part.type === \"string\") {\n        cb(part.data);\n      } else {\n        success = false;\n      }\n    }\n    return success;\n  }\n  return false;\n}\n\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  if (aType !== bType) {\n    return null;\n  }\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      if (a < b)\n        return -1;\n      if (a > b)\n        return 1;\n      return 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a);\n  const bType = getType(b);\n  const aTypeOrder = TYPE_ORDER[aType] || 100;\n  const bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder;\n  }\n  let result = partialCompare(a, b);\n  if (result === null) {\n    result = 0;\n  }\n  return result;\n}\n\nconst operators = {\n  \"==\": function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function gt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function gte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function lt(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function lte(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    if (result === null) {\n      return NULL_VALUE;\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === \"path\") {\n      if (left.type !== \"string\") {\n        return NULL_VALUE;\n      }\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    }\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE;\n        }\n      }\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function match(left, right) {\n    let tokens = [];\n    let patterns = [];\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    });\n    if (!didSucceed) {\n      return FALSE_VALUE;\n    }\n    const matched = matchText(tokens, patterns);\n    return matched ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function plus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data + right.data);\n    }\n    if (left.type === \"string\" && right.type === \"string\") {\n      return fromString(left.data + right.data);\n    }\n    if (left.type === \"object\" && right.type === \"object\") {\n      return fromJS({ ...left.data, ...right.data });\n    }\n    if (left.type === \"array\" && right.type === \"array\") {\n      return fromJS(left.data.concat(right.data));\n    }\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val;\n        }\n        for await (const val of right) {\n          yield val;\n        }\n      });\n    }\n    return NULL_VALUE;\n  },\n  \"-\": function minus(left, right) {\n    if (left.type === \"datetime\" && right.type === \"number\") {\n      return fromDateTime(left.data.add(-right.data));\n    }\n    if (left.type === \"datetime\" && right.type === \"datetime\") {\n      return fromNumber(left.data.difference(right.data));\n    }\n    if (left.type === \"number\" && right.type === \"number\") {\n      return fromNumber(left.data - right.data);\n    }\n    return NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Scope {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    __publicField$2(this, \"params\");\n    __publicField$2(this, \"source\");\n    __publicField$2(this, \"value\");\n    __publicField$2(this, \"parent\");\n    __publicField$2(this, \"context\");\n    __publicField$2(this, \"isHidden\", false);\n    this.params = params;\n    this.source = source;\n    this.value = value;\n    this.context = context;\n    this.parent = parent;\n  }\n  createNested(value) {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent);\n    }\n    return new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    result.isHidden = true;\n    return result;\n  }\n}\n\nfunction evaluate(node, scope, execute = evaluate) {\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  if (\"then\" in value) {\n    return value.then(cb);\n  }\n  return cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Selector() {\n    throw new Error(\"Selectors can not be evaluated\");\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter({ name }, scope) {\n    return fromJS(scope.params[name]);\n  },\n  Context({ key }, scope) {\n    if (key === \"before\" || key === \"after\") {\n      const value = scope.context[key];\n      return value || NULL_VALUE;\n    }\n    throw new Error(\"unknown context key: \".concat(key));\n  },\n  Parent({ n }, scope) {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE;\n      }\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall({ op, left, right }, scope, execute) {\n    const func = operators[op];\n    if (!func) {\n      throw new Error(\"Unknown operator: \".concat(op));\n    }\n    const leftValue = execute(left, scope);\n    const rightValue = execute(right, scope);\n    if (\"then\" in leftValue || \"then\" in rightValue) {\n      return (async () => func(await leftValue, await rightValue))();\n    }\n    return func(leftValue, rightValue);\n  },\n  async Select({ alternatives, fallback }, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === true) {\n        return execute(alt.value, scope);\n      }\n    }\n    if (fallback) {\n      return execute(fallback, scope);\n    }\n    return NULL_VALUE;\n  },\n  async InRange({ base, left, right, isInclusive }, scope, execute) {\n    const value = await execute(base, scope);\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    const leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null) {\n      return NULL_VALUE;\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    if (rightCmp === null) {\n      return NULL_VALUE;\n    }\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem);\n        const exprValue = await execute(expr, newScope);\n        if (exprValue.type === \"boolean\" && exprValue.data === true) {\n          yield elem;\n        }\n      }\n    });\n  },\n  async Projection({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall({ func, args }, scope, execute) {\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall({ func, base, args }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute({ base, name }, scope, execute) {\n    let value = scope.value;\n    if (base) {\n      value = await execute(base, scope);\n    }\n    if (value.type === \"object\") {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name]);\n      }\n    }\n    return NULL_VALUE;\n  },\n  async AccessElement({ base, index }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const data = await baseValue.get();\n    const finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice({ base, left, right, isInclusive }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray()) {\n      return NULL_VALUE;\n    }\n    const array = await baseValue.get();\n    let leftIdx = left;\n    let rightIdx = right;\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx;\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx;\n    }\n    if (isInclusive) {\n      rightIdx++;\n    }\n    if (leftIdx < 0) {\n      leftIdx = 0;\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0;\n    }\n    return fromJS(array.slice(leftIdx, rightIdx));\n  },\n  async Deref({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!scope.source.isArray()) {\n      return NULL_VALUE;\n    }\n    if (value.type !== \"object\") {\n      return NULL_VALUE;\n    }\n    const id = value.data._ref;\n    if (typeof id !== \"string\") {\n      return NULL_VALUE;\n    }\n    if (scope.context.dereference) {\n      return fromJS(await scope.context.dereference({ _ref: id }));\n    }\n    for await (const doc of scope.source) {\n      if (doc.type === \"object\" && id === doc.data._id) {\n        return doc;\n      }\n    }\n    return NULL_VALUE;\n  },\n  Value({ value }) {\n    return fromJS(value);\n  },\n  Group({ base }, scope, execute) {\n    return execute(base, scope);\n  },\n  async Object({ attributes }, scope, execute) {\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\": {\n          const value = await execute(attr.value, scope);\n          result[attr.name] = await value.get();\n          break;\n        }\n        case \"ObjectConditionalSplat\": {\n          const cond = await execute(attr.condition, scope);\n          if (cond.type !== \"boolean\" || cond.data === false) {\n            continue;\n          }\n          const value = await execute(attr.value, scope);\n          if (value.type === \"object\") {\n            Object.assign(result, value.data);\n          }\n          break;\n        }\n        case \"ObjectSplat\": {\n          const value = await execute(attr.value, scope);\n          if (value.type === \"object\") {\n            Object.assign(result, value.data);\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown node type: \".concat(attrType));\n      }\n    }\n    return fromJS(result);\n  },\n  Array({ elements }, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v;\n            }\n          }\n        } else {\n          yield value;\n        }\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === true) {\n        return TRUE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return FALSE_VALUE;\n  },\n  async And({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope);\n    const rightValue = await execute(right, scope);\n    if (leftValue.type === \"boolean\") {\n      if (leftValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (rightValue.type === \"boolean\") {\n      if (rightValue.data === false) {\n        return FALSE_VALUE;\n      }\n    }\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return TRUE_VALUE;\n  },\n  async Not({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (value.type !== \"boolean\") {\n      return NULL_VALUE;\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(-value.data);\n    });\n  },\n  Pos({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== \"number\") {\n        return NULL_VALUE;\n      }\n      return fromNumber(value.data);\n    });\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    });\n  },\n  async FlatMap({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!value.isArray()) {\n      return NULL_VALUE;\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        const innerValue = await execute(expr, newScope);\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner;\n          }\n        } else {\n          yield innerValue;\n        }\n      }\n    });\n  }\n};\nfunction evaluateQuery(tree, options = {}) {\n  const root = fromJS(options.root);\n  const dataset = fromJS(options.dataset);\n  const params = { ...options.params };\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n      identity: options.identity === void 0 ? \"me\" : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference\n    },\n    null\n  );\n  return evaluate(tree, scope);\n}\n\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return true;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return false;\n      }\n    default:\n      return false;\n  }\n}\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  { timestamp: /* @__PURE__ */ new Date(0), identity: \"me\", before: null, after: null },\n  null\n);\nfunction tryConstantEvaluate(node) {\n  if (!canConstantEvaluate(node)) {\n    return null;\n  }\n  return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value) {\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  }\n  return value;\n}\n\nasync function portableTextContent(value) {\n  if (value.type === \"object\") {\n    return blockText(value.data);\n  } else if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0) {\n      return texts.join(\"\\n\\n\");\n    }\n  }\n  return null;\n}\nasync function arrayText(value, result = []) {\n  for await (const block of value) {\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      if (text !== null)\n        result.push(text);\n    } else if (block.isArray()) {\n      await arrayText(block, result);\n    }\n  }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type !== \"string\")\n    return null;\n  const children = obj.children;\n  if (!Array.isArray(children))\n    return null;\n  let result = \"\";\n  for (const child of children) {\n    if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n      result += child.text;\n    }\n  }\n  return result;\n}\n\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\") {\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  }\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute);\n    const boost = await execute(node.args[1], scope);\n    if (boost.type === \"number\" && innerScore > 0) {\n      return innerScore + boost.data;\n    }\n    return 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScore(node.left, scope, execute);\n      const rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScore(node.left, scope, execute);\n      const rightScore = await evaluateScore(node.right, scope, execute);\n      if (leftScore === 0 || rightScore === 0)\n        return 0;\n      return leftScore + rightScore;\n    }\n    default: {\n      const res = await execute(node, scope);\n      return res.type === \"boolean\" && res.data === true ? 1 : 0;\n    }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope);\n  const pattern = await execute(right, scope);\n  let tokens = [];\n  let terms = [];\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part));\n  });\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part));\n  });\n  if (!didSucceed) {\n    return 0;\n  }\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0;\n  }\n  let score = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score;\n}\n\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n    case \"object\":\n      if (value._ref) {\n        return pathSet.has(value._ref);\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true;\n        }\n      }\n      break;\n  }\n  return false;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    if (code >= 55296 && code <= 56319) {\n      continue;\n    }\n    count2++;\n  }\n  return count2;\n}\nconst _global = {};\n_global.anywhere = async function anywhere() {\n  throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\") {\n      return value;\n    }\n  }\n  return NULL_VALUE;\n};\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray()) {\n    return NULL_VALUE;\n  }\n  let num = 0;\n  for await (const _ of inner) {\n    num++;\n  }\n  return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  if (val.type === \"datetime\") {\n    return val;\n  }\n  if (val.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\") {\n    return fromNumber(countUTF8(inner.data));\n  }\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner) {\n      num++;\n    }\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(\"\".concat(value.data));\n    default:\n      return NULL_VALUE;\n  }\n};\n_global.string.arity = 1;\n_global.references = async function references(args, scope, execute) {\n  const pathSet = /* @__PURE__ */ new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\") {\n      pathSet.add(path2.data);\n    } else if (path2.isArray()) {\n      for await (const elem of path2) {\n        if (elem.type === \"string\") {\n          pathSet.add(elem.data);\n        }\n      }\n    }\n  }\n  if (pathSet.size === 0) {\n    return FALSE_VALUE;\n  }\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c) => c >= 1;\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\") {\n    return NULL_VALUE;\n  }\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE;\n    }\n    prec = precValue.data;\n  }\n  if (prec === 0) {\n    if (num < 0) {\n      return fromNumber(-Math.round(-num));\n    }\n    return fromNumber(Math.round(num));\n  }\n  return fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2) => count2 >= 1 && count2 <= 2;\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function boost() {\n  throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  if (str.data.length === 0) {\n    return fromJS([]);\n  }\n  if (sep.data.length === 0) {\n    return fromJS(Array.from(str.data));\n  }\n  return fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  const prefix = await execute(args[1], scope);\n  if (prefix.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\") {\n    return NULL_VALUE;\n  }\n  let buf = \"\";\n  let needSep = false;\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data;\n    }\n    switch (elem.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        buf += \"\".concat(elem.data);\n        break;\n      default:\n        return NULL_VALUE;\n    }\n    needSep = true;\n  }\n  return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== \"null\") {\n        yield elem;\n      }\n    }\n  });\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (!value.isArray()) {\n    return NULL_VALUE;\n  }\n  return new StreamValue(async function* () {\n    const added = /* @__PURE__ */ new Set();\n    for await (const iter of value) {\n      switch (iter.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          if (!added.has(iter.data)) {\n            added.add(iter.data);\n            yield iter;\n          }\n          break;\n        default:\n          yield iter;\n      }\n    }\n  });\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  const text = await portableTextContent(value);\n  if (text === null) {\n    return NULL_VALUE;\n  }\n  return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId);\n  }\n  return NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset);\n  }\n  return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n  await true;\n  if (!base.isArray()) {\n    return NULL_VALUE;\n  }\n  const mappers = [];\n  const directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    if (mapper.type === \"Desc\") {\n      direction = \"desc\";\n      mapper = mapper.base;\n    } else if (mapper.type === \"Asc\") {\n      mapper = mapper.base;\n    }\n    mappers.push(mapper);\n    directions.push(direction);\n    n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value);\n    const tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple);\n    idx++;\n  }\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\") {\n        c = -c;\n      }\n      if (c !== 0) {\n        return c;\n      }\n    }\n    return aTuple[1] - bTuple[1];\n  });\n  return fromJS(aux.map((v) => v[0]));\n};\npipeFunctions.order.arity = (count2) => count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray())\n    return NULL_VALUE;\n  const unknown = [];\n  const scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute);\n    }\n    const newObject = Object.assign({}, value.data, { _score: valueScore });\n    scored.push(newObject);\n  }\n  scored.sort((a, b) => b._score - a._score);\n  return fromJS(scored);\n};\npipeFunctions.score.arity = (count2) => count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n  const hasBefore = scope.context.before !== null;\n  const hasAfter = scope.context.after !== null;\n  if (hasBefore && hasAfter) {\n    return fromString(\"update\");\n  }\n  if (hasAfter) {\n    return fromString(\"create\");\n  }\n  if (hasBefore) {\n    return fromString(\"delete\");\n  }\n  return NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n;\n  for await (const elem of arr) {\n    if (elem.type === \"null\")\n      continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    if (n === void 0 || elem.data < n) {\n      n = elem.data;\n    }\n  }\n  return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n;\n  for await (const elem of arr) {\n    if (elem.type === \"null\")\n      continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    if (n === void 0 || elem.data > n) {\n      n = elem.data;\n    }\n  }\n  return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n = 0;\n  for await (const elem of arr) {\n    if (elem.type === \"null\")\n      continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    n += elem.data;\n  }\n  return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray()) {\n    return NULL_VALUE;\n  }\n  let n = 0;\n  let c = 0;\n  for await (const elem of arr) {\n    if (elem.type === \"null\")\n      continue;\n    if (elem.type !== \"number\") {\n      return NULL_VALUE;\n    }\n    n += elem.data;\n    c++;\n  }\n  if (c === 0) {\n    return NULL_VALUE;\n  }\n  return fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function now2(args, scope, execute) {\n  return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n  global: _global,\n  string: string2,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime: dateTime2\n};\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MarkProcessor {\n  constructor(string, marks, parseOptions) {\n    __publicField$1(this, \"string\");\n    __publicField$1(this, \"marks\");\n    __publicField$1(this, \"index\");\n    __publicField$1(this, \"parseOptions\");\n    __publicField$1(this, \"allowBoost\", false);\n    this.string = string;\n    this.marks = marks;\n    this.index = 0;\n    this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func) {\n      throw new Error(\"Unknown handler: \".concat(mark.name));\n    }\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    this.shift();\n    return this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1];\n    const curr = this.marks[this.index];\n    this.shift();\n    return this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === \"error\")\n    return result;\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return { type: \"error\", position: pos };\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result;\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === \"error\")\n        return rhs;\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case \",\": {\n          marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === \"error\")\n              return rhs;\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== \",\")\n              break;\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== \")\")\n            return { type: \"error\", position: pos };\n          pos++;\n          marks.push({ name: \"tuple_end\", position: pos });\n          break;\n        }\n        case \")\": {\n          pos++;\n          marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n          break;\n        }\n        default:\n          return { type: \"error\", position: pos };\n      }\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks);\n      pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks;\n      pos = result.position;\n      break;\n    }\n    case \"[\":\n      marks = [{ name: \"array\", position: pos }];\n      pos = skipWS(str, pos + 1);\n      if (str[pos] !== \"]\") {\n        while (true) {\n          if (str.slice(pos, pos + 3) === \"...\") {\n            marks.push({ name: \"array_splat\", position: pos });\n            pos = skipWS(str, pos + 3);\n          }\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\")\n            return res;\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== \",\")\n            break;\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === \"]\")\n            break;\n        }\n      }\n      if (str[pos] === \"]\") {\n        pos++;\n        marks.push({ name: \"array_end\", position: pos });\n      } else {\n        return { type: \"error\", position: pos };\n      }\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks;\n      pos = result.position;\n      break;\n    }\n    case \"^\": {\n      pos++;\n      marks = [];\n      while (str[pos] === \".\" && str[pos + 1] === \"^\") {\n        marks.push({ name: \"dblparent\", position: startPos });\n        pos += 2;\n      }\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }];\n      pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }];\n      pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          { name: \"param\", position: startPos },\n          { name: \"ident\", position: startPos + 1 },\n          { name: \"ident_end\", position: pos }\n        ];\n      }\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = \"float\";\n            pos += 1 + fracLen;\n          }\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\";\n          pos++;\n          if (str[pos] === \"+\" || str[pos] === \"-\") {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen)\n            return { type: \"error\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\")\n              return result;\n            marks = result.marks;\n            pos = result.position;\n            break;\n          }\n          default: {\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n          }\n        }\n        break;\n      }\n    }\n  }\n  if (!marks) {\n    return { type: \"error\", position: pos };\n  }\n  let lhsLevel = 12;\n  let trav;\n  loop:\n    while (true) {\n      let innerPos = skipWS(str, pos);\n      if (innerPos === str.length) {\n        pos = innerPos;\n        break;\n      }\n      trav = parseTraversal(str, innerPos);\n      if (trav.type === \"success\") {\n        marks.unshift({ name: \"traverse\", position: startPos });\n        while (trav.type === \"success\") {\n          marks = marks.concat(trav.marks);\n          pos = trav.position;\n          trav = parseTraversal(str, skipWS(str, pos));\n        }\n        marks.push({ name: \"traversal_end\", position: pos });\n        continue;\n      }\n      let token2 = str[innerPos];\n      switch (token2) {\n        case \"=\": {\n          let nextToken = str[innerPos + 1];\n          switch (nextToken) {\n            case \">\": {\n              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks = marks.concat(rhs.marks);\n              marks.unshift({ name: \"pair\", position: startPos });\n              pos = rhs.position;\n              lhsLevel = PREC_PAIR;\n              break;\n            }\n            case \"=\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos });\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n              marks = marks.concat(rhs.marks);\n              pos = rhs.position;\n              lhsLevel = PREC_COMP;\n              break;\n            }\n            default:\n              break loop;\n          }\n          break;\n        }\n        case \"+\": {\n          if (level > PREC_ADD || lhsLevel < PREC_ADD)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"add\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_ADD;\n          break;\n        }\n        case \"-\": {\n          if (level > PREC_SUB || lhsLevel < PREC_SUB)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"sub\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_SUB;\n          break;\n        }\n        case \"*\": {\n          if (str[innerPos + 1] === \"*\") {\n            if (level > PREC_POW || lhsLevel <= PREC_POW)\n              break loop;\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n            if (rhs2.type === \"error\")\n              return rhs2;\n            marks = marks.concat(rhs2.marks);\n            marks.unshift({ name: \"pow\", position: startPos });\n            pos = rhs2.position;\n            lhsLevel = PREC_POW;\n            break;\n          }\n          if (level > PREC_MUL || lhsLevel < PREC_MUL)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"mul\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_MUL;\n          break;\n        }\n        case \"/\": {\n          if (level > PREC_DIV || lhsLevel < PREC_DIV)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"div\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_DIV;\n          break;\n        }\n        case \"%\": {\n          if (level > PREC_MOD || lhsLevel < PREC_MOD)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"mod\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_MOD;\n          break;\n        }\n        case \"<\":\n        case \">\": {\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n            break loop;\n          let nextPos = innerPos + 1;\n          if (str[nextPos] === \"=\") {\n            nextPos++;\n          }\n          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos });\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n        case \"|\": {\n          if (str[innerPos + 1] === \"|\") {\n            if (level > PREC_OR || lhsLevel < PREC_OR)\n              break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n            if (rhs.type === \"error\")\n              return rhs;\n            marks = marks.concat(rhs.marks);\n            marks.unshift({ name: \"or\", position: startPos });\n            pos = rhs.position;\n            lhsLevel = PREC_OR;\n          } else {\n            if (level > 11 || lhsLevel < 11)\n              break loop;\n            let identPos = skipWS(str, innerPos + 1);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (!identLen)\n              return { type: \"error\", position: identPos };\n            pos = identPos + identLen;\n            if (str[pos] === \"(\" || str[pos] === \":\") {\n              let result = parseFuncCall(str, identPos, pos);\n              if (result.type === \"error\")\n                return result;\n              marks = marks.concat(result.marks);\n              marks.unshift({ name: \"pipecall\", position: startPos });\n              pos = result.position;\n              lhsLevel = 11;\n            }\n          }\n          break;\n        }\n        case \"&\": {\n          if (str[innerPos + 1] != \"&\")\n            break loop;\n          if (level > PREC_AND || lhsLevel < PREC_AND)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks);\n          marks.unshift({ name: \"and\", position: startPos });\n          pos = rhs.position;\n          lhsLevel = PREC_AND;\n          break;\n        }\n        case \"!\": {\n          if (str[innerPos + 1] !== \"=\")\n            break loop;\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos });\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n          marks = marks.concat(rhs.marks);\n          pos = rhs.position;\n          lhsLevel = PREC_COMP;\n          break;\n        }\n        case \"d\": {\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\")\n            break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\n            break loop;\n          marks.unshift({ name: \"desc\", position: startPos });\n          pos = innerPos + 4;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n        case \"a\": {\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\")\n            break loop;\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\n            break loop;\n          marks.unshift({ name: \"asc\", position: startPos });\n          pos = innerPos + 3;\n          lhsLevel = PREC_ORDER;\n          break;\n        }\n        default: {\n          let ident = parseRegexStr(str, innerPos, IDENT);\n          switch (ident) {\n            case \"in\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              pos = skipWS(str, innerPos + 2);\n              let isGroup = false;\n              if (str[pos] === \"(\") {\n                isGroup = true;\n                pos = skipWS(str, pos + 1);\n              }\n              let rangePos = pos;\n              let result = parseExpr(str, pos, PREC_COMP + 1);\n              if (result.type === \"error\")\n                return result;\n              pos = skipWS(str, result.position);\n              if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                let type = \"inc_range\";\n                if (str[pos + 2] === \".\") {\n                  type = \"exc_range\";\n                  pos = skipWS(str, pos + 3);\n                } else {\n                  pos = skipWS(str, pos + 2);\n                }\n                let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                if (rhs.type === \"error\")\n                  return rhs;\n                marks.unshift({ name: \"in_range\", position: startPos });\n                marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks);\n                pos = rhs.position;\n              } else {\n                marks.unshift({ name: \"comp\", position: startPos });\n                marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\n                marks = marks.concat(result.marks);\n              }\n              if (isGroup) {\n                pos = skipWS(str, pos);\n                if (str[pos] !== \")\")\n                  return { type: \"error\", position: pos };\n                pos++;\n              }\n              lhsLevel = PREC_COMP;\n              break;\n            }\n            case \"match\": {\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos });\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 });\n              marks = marks.concat(rhs.marks);\n              pos = rhs.position;\n              lhsLevel = 4;\n              break;\n            }\n            default: {\n              break loop;\n            }\n          }\n        }\n      }\n    }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen2 = parseRegex(str, pos, IDENT);\n      if (!identLen2)\n        return { type: \"error\", position: pos };\n      pos += identLen2;\n      return {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push(\n          { name: \"deref_attr\", position: identPos },\n          { name: \"ident\", position: identPos },\n          { name: \"ident_end\", position: pos }\n        );\n      }\n      return {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \"]\") {\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      }\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      pos = skipWS(str, result.position);\n      if (str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        if (str[pos + 2] === \".\") {\n          type = \"exc_range\";\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === \"error\")\n          return rhs;\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== \"]\")\n          return { type: \"error\", position: pos };\n        return {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        };\n      }\n      if (str[pos] !== \"]\")\n        return { type: \"error\", position: pos };\n      return {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        if (result.type === \"error\")\n          return result;\n        result.marks.unshift({ name: \"projection\", position: startPos });\n        return result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      result.marks.unshift({ name: \"projection\", position: startPos });\n      return result;\n    }\n  }\n  return { type: \"error\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  marks.push({ name: \"func_call\", position: startPos });\n  if (str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos });\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen)\n      return { type: \"error\", position: pos };\n    marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen });\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== \"(\")\n      return { type: \"error\", position: pos };\n    pos++;\n    pos = skipWS(str, pos);\n  } else {\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\n    pos = skipWS(str, pos + 1);\n  }\n  let lastPos = pos;\n  if (str[pos] !== \")\") {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== \",\")\n        break;\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === \")\")\n        break;\n    }\n  }\n  if (str[pos] !== \")\") {\n    return { type: \"error\", position: pos };\n  }\n  marks.push({ name: \"func_args_end\", position: lastPos });\n  return {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  };\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  pos = skipWS(str, pos + 1);\n  while (str[pos] !== \"}\") {\n      let pairPos = pos;\n      if (str.slice(pos, pos + 3) === \"...\") {\n        pos = skipWS(str, pos + 3);\n        if (str[pos] !== \"}\" && str[pos] !== \",\") {\n          let expr = parseExpr(str, pos, 0);\n          if (expr.type === \"error\")\n            return expr;\n          marks.push({ name: \"object_splat\", position: pairPos });\n          marks = marks.concat(expr.marks);\n          pos = expr.position;\n        } else {\n          marks.push({ name: \"object_splat_this\", position: pairPos });\n        }\n      } else {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\")\n          return expr;\n        let nextPos = skipWS(str, expr.position);\n        if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n          let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n          if (value.type === \"error\")\n            return value;\n          marks.push({ name: \"object_pair\", position: pairPos });\n          marks = marks.concat(expr.marks, value.marks);\n          pos = value.position;\n        } else {\n          marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks);\n          pos = expr.position;\n        }\n      }\n      pos = skipWS(str, pos);\n      if (str[pos] !== \",\")\n        break;\n      pos = skipWS(str, pos + 1);\n    }\n  if (str[pos] !== \"}\") {\n    return { type: \"error\", position: pos };\n  }\n  pos++;\n  marks.push({ name: \"object_end\", position: pos });\n  return { type: \"success\", marks, position: pos };\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str:\n    for (; ; pos++) {\n      if (pos > str.length)\n        return { type: \"error\", position: pos };\n      switch (str[pos]) {\n        case token: {\n          marks.push({ name: \"str_end\", position: pos });\n          pos++;\n          break str;\n        }\n        case \"\\\\\": {\n          marks.push({ name: \"str_pause\", position: pos });\n          if (str[pos + 1] === \"u\") {\n            if (str[pos + 2] === \"{\") {\n              marks.push({ name: \"unicode_hex\", position: pos + 3 });\n              pos = str.indexOf(\"}\", pos + 3);\n              marks.push({ name: \"unicode_hex_end\", position: pos });\n            } else {\n              marks.push({ name: \"unicode_hex\", position: pos + 2 });\n              marks.push({ name: \"unicode_hex_end\", position: pos + 6 });\n              pos += 5;\n            }\n          } else {\n            marks.push({ name: \"single_escape\", position: pos + 1 });\n            pos += 1;\n          }\n          marks.push({ name: \"str_start\", position: pos + 1 });\n        }\n      }\n    }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\n\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right) {\n    return {\n      type: \"a-a\",\n      build\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right) {\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right) {\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  }\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(\"unknown type: \".concat(right.type));\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"GroqQueryError\");\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER);\n    return {\n      type: \"Group\",\n      base: inner\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER);\n    return {\n      type: \"Parent\",\n      n: next.n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER);\n    const traversalList = [];\n    while (p.getMark().name !== \"traversal_end\") {\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    }\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal);\n    }\n    if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n      traversal = traverseArray((val) => val, traversal);\n    }\n    if (traversal === null)\n      throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    if (name === \"null\") {\n      return { type: \"Value\", value: null };\n    }\n    if (name === \"true\") {\n      return { type: \"Value\", value: true };\n    }\n    if (name === \"false\") {\n      return { type: \"Value\", value: false };\n    }\n    return {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Neg\",\n      base\n    };\n  },\n  pos(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Pos\",\n      base\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER);\n    const op = p.processString();\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER);\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop:\n      while (p.hasMark()) {\n        const mark = p.getMark();\n        switch (mark.name) {\n          case \"str_end\":\n            value += p.processStringEnd();\n            break loop;\n          case \"str_pause\":\n            value += p.processStringEnd();\n            break;\n          case \"str_start\":\n            p.shift();\n            break;\n          case \"single_escape\": {\n            const char = p.slice(1);\n            p.shift();\n            value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n          case \"unicode_hex\":\n            p.shift();\n            value += expandHex(p.processStringEnd());\n            break;\n          default:\n            throw new Error(\"unexpected mark: \".concat(mark.name));\n        }\n      }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    while (p.getMark().name !== \"object_end\") {\n      attributes.push(p.process(OBJECT_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    while (p.getMark().name !== \"array_end\") {\n      let isSplat = false;\n      if (p.getMark().name === \"array_splat\") {\n        isSplat = true;\n        p.shift();\n      }\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    p.shift();\n    return {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    while (p.getMark().name !== \"tuple_end\") {\n      members.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    return {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      while (p.getMark().name !== \"func_args_end\") {\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback)\n            throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER);\n          const value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback)\n            throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      }\n      p.shift();\n      return result;\n    }\n    const args = [];\n    while (p.getMark().name !== \"func_args_end\") {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        p.process(SELECTOR_BUILDER);\n        args.push({ type: \"Selector\" });\n      } else {\n        args.push(p.process(EXPR_BUILDER));\n      }\n    }\n    p.shift();\n    if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n      if (p.parseOptions.mode === \"delta\") {\n        return {\n          type: \"Context\",\n          key: name\n        };\n      }\n    }\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs) {\n      throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n    }\n    const func = funcs[name];\n    if (!func) {\n      throw new GroqQueryError(\"Undefined function: \".concat(name));\n    }\n    if (func.arity !== void 0) {\n      validateArity(name, func.arity, args.length);\n    }\n    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(\"Undefined function: \".concat(name));\n    }\n    return {\n      type: \"FuncCall\",\n      func,\n      namespace,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\") {\n      p.shift();\n      namespace = p.processString();\n    }\n    if (namespace !== \"global\") {\n      throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n    }\n    const name = p.processString();\n    const args = [];\n    const oldAllowBoost = p.allowBoost;\n    if (name === \"score\") {\n      p.allowBoost = true;\n    }\n    for (; ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\") {\n        break;\n      }\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift();\n          args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift();\n          args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift();\n    p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func) {\n      throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length);\n    }\n    return {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair(p) {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    const base = p.process(EXPR_BUILDER);\n    return {\n      type: \"Not\",\n      base\n    };\n  },\n  asc(p) {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc(p) {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: \"Value\",\n        value: p.parseOptions.params[name]\n      };\n    }\n    return {\n      type: \"Parameter\",\n      name\n    };\n  }\n};\nconst OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER);\n      const value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\")\n      throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectSplat\",\n      value\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n};\nconst TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER);\n    const value = tryConstantEvaluate(expr);\n    if (value && value.type === \"number\") {\n      return (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right);\n    }\n    if (value && value.type === \"string\") {\n      return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right);\n    }\n    return (right) => traverseArray(\n      (base) => ({\n        type: \"Filter\",\n        base,\n        expr\n      }),\n      right\n    );\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER);\n    const right = p.process(EXPR_BUILDER);\n    const leftValue = tryConstantEvaluate(left);\n    const rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    }\n    return (rhs) => traverseArray(\n      (base) => ({\n        type: \"Slice\",\n        base,\n        left: leftValue.data,\n        right: rightValue.data,\n        isInclusive\n      }),\n      rhs\n    );\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    if (p.getMark().name === \"deref_attr\") {\n      p.shift();\n      attr = p.processString();\n    }\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain(\n      (base) => wrap({\n        type: \"Deref\",\n        base\n      }),\n      right\n    );\n  },\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n};\nconst SELECTOR_BUILDER = {\n  group(p) {\n    p.process(SELECTOR_BUILDER);\n    return null;\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    p.process(SELECTOR_BUILDER);\n    while (p.getMark().name !== \"traversal_end\") {\n      p.process(TRAVERSE_BUILDER);\n    }\n    p.shift();\n    return null;\n  },\n  this_attr(p) {\n    p.processString();\n    return null;\n  },\n  neg(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1)\n      return null;\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param(p) {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base) {\n    return node.name;\n  }\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n    return extractPropertyKey(node.base);\n  }\n  throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity === \"number\") {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        \"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\")\n      );\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n    }\n  }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(\"Syntax error in GROQ query at position \".concat(position));\n    __publicField(this, \"position\");\n    __publicField(this, \"name\", \"GroqSyntaxError\");\n    this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\") {\n    throw new GroqSyntaxError(result.position);\n  }\n  const processor = new MarkProcessor(input, result.marks, options);\n  return processor.process(EXPR_BUILDER);\n}\n\n\n//# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxHQUFHO0FBQ3RDLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBLElBQUksbUZBQW1GO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0NBQWtDO0FBQ3ZELFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQyxZQUFZLHVDQUF1QztBQUNuRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZELGdCQUFnQixtQ0FBbUM7QUFDbkQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEUsMkJBQTJCLGdDQUFnQyxJQUFJLHdDQUF3QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVELHVCQUF1QixnQ0FBZ0MsSUFBSSxtQ0FBbUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCx1QkFBdUIsZ0NBQWdDLElBQUksd0NBQXdDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQ0FBc0M7QUFDdEUsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQixnQ0FBZ0Msa0NBQWtDO0FBQ2xFLDZCQUE2QixnQ0FBZ0MsSUFBSSx3Q0FBd0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRSwyQkFBMkIsZ0NBQWdDLElBQUksd0NBQXdDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQXlDO0FBQ3JELFlBQVkscUNBQXFDO0FBQ2pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRCxZQUFZLG1DQUFtQztBQUMvQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RDtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQsaUJBQWlCLG1DQUFtQyxJQUFJLGtDQUFrQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCLDhCQUE4QixJQUFJLDRDQUE0QztBQUMvRjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCLG1DQUFtQyxJQUFJLGtDQUFrQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUsMENBQTBDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlDQUF5QztBQUNoRTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1Qiw4Q0FBOEM7QUFDckU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVU7QUFDVixpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBLG1DQUFtQztBQUNuQywyQkFBMkIsd0NBQXdDO0FBQ25FLGtDQUFrQztBQUNsQywyQkFBMkIsd0NBQXdDO0FBQ25FLGNBQWM7QUFDZCwyQkFBMkIsd0NBQXdDO0FBQ25FLDJCQUEyQiw0Q0FBNEM7QUFDdkU7QUFDQTtBQUNBLFlBQVk7QUFDWix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDLGNBQWMsR0FBRztBQUN4RTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQyxjQUFjLEdBQUc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFD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QSxpREFBaUQscUNBQXFDO0FBQ3RGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQTRDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFsdG9yLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLm1qcz8zMThlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkNShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gIGNvbnN0IHJlID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuLnNwbGl0KFwiLlwiKSkge1xuICAgIGlmIChwYXJ0ID09PSBcIipcIikge1xuICAgICAgcmUucHVzaChcIlteLl0rXCIpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIqKlwiKSB7XG4gICAgICByZS5wdXNoKFwiLipcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHJlLmpvaW4oXCIuXCIpLCBcIiRcIikpO1xufVxuY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuXCIpO1xuICAgIF9fcHVibGljRmllbGQkNSh0aGlzLCBcInBhdHRlcm5SZVwiKTtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgfVxuICBtYXRjaGVzKHN0cikge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm5SZS50ZXN0KHN0cik7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gIH1cbn1cblxudmFyIF9fZGVmUHJvcCQ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQ0ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ0KG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQ0KG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidHlwZVwiLCBcInN0cmVhbVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJnZW5lcmF0b3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidGlja2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImlzRG9uZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJkYXRhXCIpO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcykge1xuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQgdGhpcy5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGljayA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlcigpO1xuICAgICAgc2V0dXBUaWNrZXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzLmdlbmVyYXRvcigpKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGljaygpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgdGljaygpO1xuICAgIH07XG4gICAgc2V0dXBUaWNrZXIoKTtcbiAgICBmZXRjaCgpO1xuICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgfVxufVxuXG5jb25zdCBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICBpZiAoUkZDMzMzOV9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc3RyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xuICBjb25zdCB5ZWFyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENGdWxsWWVhcigpLCA0KTtcbiAgY29uc3QgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKTtcbiAgY29uc3QgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpO1xuICBjb25zdCBob3VyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENIb3VycygpLCAyKTtcbiAgY29uc3QgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpO1xuICBjb25zdCBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XG4gIGxldCBmcmFjdGlvbmFsU2Vjb25kID0gXCJcIjtcbiAgY29uc3QgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgZnJhY3Rpb25hbFNlY29uZCA9IFwiLlwiLmNvbmNhdChhZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpKTtcbiAgfVxuICByZXR1cm4gXCJcIi5jb25jYXQoeWVhciwgXCItXCIpLmNvbmNhdChtb250aCwgXCItXCIpLmNvbmNhdChkYXksIFwiVFwiKS5jb25jYXQoaG91ciwgXCI6XCIpLmNvbmNhdChtaW51dGUsIFwiOlwiKS5jb25jYXQoc2Vjb25kKS5jb25jYXQoZnJhY3Rpb25hbFNlY29uZCwgXCJaXCIpO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcbiAgbGV0IHN0ciA9IG51bS50b1N0cmluZygpO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIHN0ciA9IFwiMFwiLmNvbmNhdChzdHIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQzID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMyhvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBTdGF0aWNWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJkYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInR5cGVcIik7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJhcnJheVwiO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSkge1xuICAgICAgICAgIHlpZWxkIGZyb21KUyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBvdmVyOiBcIi5jb25jYXQodGhpcy50eXBlKSk7XG4gIH1cbn1cbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpO1xuY29uc3QgVFJVRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSh0cnVlLCBcImJvb2xlYW5cIik7XG5jb25zdCBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShmYWxzZSwgXCJib29sZWFuXCIpO1xuY2xhc3MgRGF0ZVRpbWUge1xuICBjb25zdHJ1Y3RvcihkYXRlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGF0ZVwiKTtcbiAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIGlmIChkYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUocGF0aCwgXCJwYXRoXCIpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgaWYgKGlzSXRlcmF0b3IodmFsKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKSB7XG4gICAgICAgIHlpZWxkIGZyb21KUyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUGF0aCkge1xuICAgIHJldHVybiBcInBhdGhcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lKSB7XG4gICAgcmV0dXJuIFwiZGF0ZXRpbWVcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICBpZiAoYS50eXBlID09PSBcInN0cmluZ1wiICYmIGIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGIudHlwZSA9PT0gXCJib29sZWFuXCIgfHwgYS50eXBlID09PSBcIm51bGxcIiAmJiBiLnR5cGUgPT09IFwibnVsbFwiIHx8IGEudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBiLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhID09PSBiLmRhdGE7XG4gIH1cbiAgaWYgKGEudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIGIudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIGEuZGF0YS5lcXVhbHMoYi5kYXRhKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG5jb25zdCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmNvbnN0IE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5zLmV2ZXJ5KChwYXR0ZXJuKSA9PiBwYXR0ZXJuKHRva2VucykpO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlMpIHx8IFtdO1xufVxuZnVuY3Rpb24gbWF0Y2hBbmFseXplUGF0dGVybih0ZXh0KSB7XG4gIGNvbnN0IHRlcm1zUmUgPSBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KTtcbiAgcmV0dXJuIHRlcm1zUmUubWFwKChyZSkgPT4gKHRva2VucykgPT4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiByZS50ZXN0KHRva2VuKSkpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkge1xuICBjb25zdCB0ZXJtcyA9IHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSU19XSVRIX1dJTERDQVJEKSB8fCBbXTtcbiAgcmV0dXJuIHRlcm1zLm1hcChcbiAgICAodGVybSkgPT4gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQodGVybS5zbGljZSgwLCBNQVhfVEVSTV9MRU5HVEgpLnJlcGxhY2UoL1xcKi9nLCBcIi4qXCIpLCBcIiRcIiksIFwiaVwiKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjYih2YWx1ZS5kYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB2YWx1ZSkge1xuICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYihwYXJ0LmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgaWYgKGEgPCBiKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoYSA+IGIpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgY29uc3QgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMDtcbiAgY29uc3QgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpIHtcbiAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGEsIGIpO1xuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ID4gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI+PVwiOiBmdW5jdGlvbiBndGUobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPFwiOiBmdW5jdGlvbiBsdChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICBpbjogYXN5bmMgZnVuY3Rpb24gaW5vcChsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIikge1xuICAgICAgaWYgKGxlZnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodC5kYXRhLm1hdGNoZXMobGVmdC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KSB7XG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGIpKSB7XG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgcGF0dGVybnMgPSBbXTtcbiAgICBhd2FpdCBnYXRoZXJUZXh0KGxlZnQsIChwYXJ0KSA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCAocGFydCkgPT4ge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgfSk7XG4gICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG4gICAgcmV0dXJuIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZyb21KUyh7IC4uLmxlZnQuZGF0YSwgLi4ucmlnaHQuZGF0YSB9KTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgcmV0dXJuIGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBsZWZ0KSB7XG4gICAgICAgICAgeWllbGQgdmFsO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHJpZ2h0KSB7XG4gICAgICAgICAgeWllbGQgdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiLVwiOiBmdW5jdGlvbiBtaW51cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCIqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAqIGIpLFxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcbiAgXCIqKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKVxufTtcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG5cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMihvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBTY29wZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwicGFyYW1zXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInNvdXJjZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJ2YWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwYXJlbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiY29udGV4dFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJpc0hpZGRlblwiLCBmYWxzZSk7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgY3JlYXRlTmVzdGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmVzdWx0LmlzSGlkZGVuID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlLCBleGVjdXRlID0gZXZhbHVhdGUpIHtcbiAgY29uc3QgZnVuYyA9IEVYRUNVVE9SU1tub2RlLnR5cGVdO1xuICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG5mdW5jdGlvbiBwcm9taXNlbGVzc0FwcGx5KHZhbHVlLCBjYikge1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudGhlbihjYik7XG4gIH1cbiAgcmV0dXJuIGNiKHZhbHVlKTtcbn1cbmNvbnN0IEVYRUNVVE9SUyA9IHtcbiAgVGhpcyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgfSxcbiAgU2VsZWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgfSxcbiAgUGFyYW1ldGVyKHsgbmFtZSB9LCBzY29wZSkge1xuICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcbiAgfSxcbiAgQ29udGV4dCh7IGtleSB9LCBzY29wZSkge1xuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc2NvcGUuY29udGV4dFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlIHx8IE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gY29udGV4dCBrZXk6IFwiLmNvbmNhdChrZXkpKTtcbiAgfSxcbiAgUGFyZW50KHsgbiB9LCBzY29wZSkge1xuICAgIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3I6IFwiLmNvbmNhdChvcCkpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChcInRoZW5cIiBpbiBsZWZ0VmFsdWUgfHwgXCJ0aGVuXCIgaW4gcmlnaHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiBmdW5jKGF3YWl0IGxlZnRWYWx1ZSwgYXdhaXQgcmlnaHRWYWx1ZSkpKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gIH0sXG4gIGFzeW5jIFNlbGVjdCh7IGFsdGVybmF0aXZlcywgZmFsbGJhY2sgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBhbHRlcm5hdGl2ZXMpIHtcbiAgICAgIGNvbnN0IGFsdENvbmQgPSBhd2FpdCBleGVjdXRlKGFsdC5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgIGlmIChhbHRDb25kLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGFsdENvbmQuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZShhbHQudmFsdWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZShmYWxsYmFjaywgc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgSW5SYW5nZSh7IGJhc2UsIGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBjb25zdCBsZWZ0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IGxlZnRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKGxlZnRDbXAgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCByaWdodENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCByaWdodFZhbHVlLmdldCgpKTtcbiAgICBpZiAocmlnaHRDbXAgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAoaXNJbmNsdXNpdmUpIHtcbiAgICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEZpbHRlcih7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYmFzZVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGVsZW0pO1xuICAgICAgICBjb25zdCBleHByVmFsdWUgPSBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgICAgaWYgKGV4cHJWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBleHByVmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHlpZWxkIGVsZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgUHJvamVjdGlvbih7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgIHJldHVybiBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgfSxcbiAgRnVuY0NhbGwoeyBmdW5jLCBhcmdzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIGZ1bmMoYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBQaXBlRnVuY0NhbGwoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIGZ1bmMoYmFzZVZhbHVlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0F0dHJpYnV0ZSh7IGJhc2UsIG5hbWUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQgdmFsdWUgPSBzY29wZS52YWx1ZTtcbiAgICBpZiAoYmFzZSkge1xuICAgICAgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICh2YWx1ZS5kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBY2Nlc3NFbGVtZW50KHsgYmFzZSwgaW5kZXggfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xuICAgIGNvbnN0IGZpbmFsSW5kZXggPSBpbmRleCA8IDAgPyBpbmRleCArIGRhdGEubGVuZ3RoIDogaW5kZXg7XG4gICAgcmV0dXJuIGZyb21KUyhkYXRhW2ZpbmFsSW5kZXhdKTtcbiAgfSxcbiAgYXN5bmMgU2xpY2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBhcnJheSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBsZXQgbGVmdElkeCA9IGxlZnQ7XG4gICAgbGV0IHJpZ2h0SWR4ID0gcmlnaHQ7XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gYXJyYXkubGVuZ3RoICsgbGVmdElkeDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSBhcnJheS5sZW5ndGggKyByaWdodElkeDtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByaWdodElkeCsrO1xuICAgIH1cbiAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgIGxlZnRJZHggPSAwO1xuICAgIH1cbiAgICBpZiAocmlnaHRJZHggPCAwKSB7XG4gICAgICByaWdodElkeCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMoYXJyYXkuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcbiAgfSxcbiAgYXN5bmMgRGVyZWYoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHsgX3JlZjogaWQgfSkpO1xuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBzY29wZS5zb3VyY2UpIHtcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBWYWx1ZSh7IHZhbHVlIH0pIHtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICB9LFxuICBhc3luYyBPYmplY3QoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gYXdhaXQgdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIjoge1xuICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgY29uZC5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiLmNvbmNhdChhdHRyVHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKHJlc3VsdCk7XG4gIH0sXG4gIEFycmF5KHsgZWxlbWVudHMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBUdXBsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIGFzeW5jIE9yKHsgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQW5kKHsgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTm90KHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgUG9zKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgfSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcbiAgICAgICAgeWllbGQgYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIEZsYXRNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoaW5uZXJWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGlubmVyIG9mIGlubmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHlpZWxkIGlubmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBpbm5lclZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByb290ID0gZnJvbUpTKG9wdGlvbnMucm9vdCk7XG4gIGNvbnN0IGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KTtcbiAgY29uc3QgcGFyYW1zID0geyAuLi5vcHRpb25zLnBhcmFtcyB9O1xuICBjb25zdCBzY29wZSA9IG5ldyBTY29wZShcbiAgICBwYXJhbXMsXG4gICAgZGF0YXNldCxcbiAgICByb290LFxuICAgIHtcbiAgICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBpZGVudGl0eTogb3B0aW9ucy5pZGVudGl0eSA9PT0gdm9pZCAwID8gXCJtZVwiIDogb3B0aW9ucy5pZGVudGl0eSxcbiAgICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgICBiZWZvcmU6IG9wdGlvbnMuYmVmb3JlID8gZnJvbUpTKG9wdGlvbnMuYmVmb3JlKSA6IG51bGwsXG4gICAgICBkZXJlZmVyZW5jZTogb3B0aW9ucy5kZXJlZmVyZW5jZVxuICAgIH0sXG4gICAgbnVsbFxuICApO1xuICByZXR1cm4gZXZhbHVhdGUodHJlZSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUoXG4gIHt9LFxuICBOVUxMX1ZBTFVFLFxuICBOVUxMX1ZBTFVFLFxuICB7IHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApLCBpZGVudGl0eTogXCJtZVwiLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sXG4gIG51bGxcbik7XG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgaWYgKCFjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNvbnN0YW50RXZhbHVhdGUobm9kZSk7XG59XG5mdW5jdGlvbiBjb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgY29uc3QgdmFsdWUgPSBldmFsdWF0ZShub2RlLCBEVU1NWV9TQ09QRSwgY29uc3RhbnRFdmFsdWF0ZSk7XG4gIGlmIChcInRoZW5cIiBpbiB2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogY29uc3RhbnQgZXZhbHVhdGUgc2hvdWxkIG5ldmVyIHJldHVybiBhIHByb21pc2VcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBjb25zdCB0ZXh0cyA9IGF3YWl0IGFycmF5VGV4dCh2YWx1ZSk7XG4gICAgaWYgKHRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSkge1xuICAgIGlmIChibG9jay50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYmxvY2tUZXh0KGJsb2NrLmRhdGEpO1xuICAgICAgaWYgKHRleHQgIT09IG51bGwpXG4gICAgICAgIHJlc3VsdC5wdXNoKHRleHQpO1xuICAgIH0gZWxzZSBpZiAoYmxvY2suaXNBcnJheSgpKSB7XG4gICAgICBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBjaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgdHlwZW9mIGNoaWxkLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlc3VsdCArPSBjaGlsZC50ZXh0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBub2RlLm5hbWUgPT09IFwiYm9vc3RcIikge1xuICAgIGNvbnN0IGlubmVyU2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgIGNvbnN0IGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAoYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCkge1xuICAgICAgcmV0dXJuIGlubmVyU2NvcmUgKyBib29zdC5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgfVxuICAgIGNhc2UgXCJBbmRcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIGNvbnN0IHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIGlmIChsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSB0cnVlID8gMSA6IDA7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgY29uc3QgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgdGVybXMgPSBbXTtcbiAgYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCAocGFydCkgPT4ge1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gIH0pO1xuICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4ge1xuICAgIHRlcm1zID0gdGVybXMuY29uY2F0KG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKTtcbiAgfSk7XG4gIGlmICghZGlkU3VjY2VlZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRlcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBzY29yZSA9IDA7XG4gIGZvciAoY29uc3QgcmUgb2YgdGVybXMpIHtcbiAgICBjb25zdCBmcmVxID0gdG9rZW5zLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgIHNjb3JlICs9IGZyZXEgKiAoQk0yNWsgKyAxKSAvIChmcmVxICsgQk0yNWspO1xuICB9XG4gIHJldHVybiBzY29yZTtcbn1cblxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XG4gIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50VVRGOChzdHIpIHtcbiAgbGV0IGNvdW50MiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb3VudDIrKztcbiAgfVxuICByZXR1cm4gY291bnQyO1xufVxuY29uc3QgX2dsb2JhbCA9IHt9O1xuX2dsb2JhbC5hbnl3aGVyZSA9IGFzeW5jIGZ1bmN0aW9uIGFueXdoZXJlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuX2dsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgIG51bSsrO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIH1cbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgICAgbnVtKys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gYXN5bmMgZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XG59O1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24gc3RyaW5nKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiXCIuY29uY2F0KHZhbHVlLmRhdGEpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5fZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbiByZWZlcmVuY2VzKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHBhdGhTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgcGF0aDIgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmIChwYXRoMi50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXRoU2V0LmFkZChwYXRoMi5kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHBhdGgyLmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHBhdGgyKSB7XG4gICAgICAgIGlmIChlbGVtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBwYXRoU2V0LmFkZChlbGVtLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXRoU2V0LnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2NvcGVWYWx1ZSA9IGF3YWl0IHNjb3BlLnZhbHVlLmdldCgpO1xuICByZXR1cm4gaGFzUmVmZXJlbmNlKHNjb3BlVmFsdWUsIHBhdGhTZXQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbl9nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IChjKSA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24gcm91bmQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICB9XG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKTtcbiAgfVxuICByZXR1cm4gZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcbn07XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XG5fZ2xvYmFsLm5vdyA9IGFzeW5jIGZ1bmN0aW9uIG5vdyhhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbn07XG5fZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG5fZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24gYm9vc3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5fZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbmNvbnN0IHN0cmluZzIgPSB7fTtcbnN0cmluZzIubG93ZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSk7XG59O1xuc3RyaW5nMi5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcyLnVwcGVyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBzZXAgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgaWYgKHNlcC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgaWYgKHN0ci5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmcm9tSlMoW10pO1xuICB9XG4gIGlmIChzZXAuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbUpTKEFycmF5LmZyb20oc3RyLmRhdGEpKTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKHN0ci5kYXRhLnNwbGl0KHNlcC5kYXRhKSk7XG59O1xuc3RyaW5nMi5zcGxpdC5hcml0eSA9IDI7XG5fZ2xvYmFsLmxvd2VyID0gc3RyaW5nMi5sb3dlcjtcbl9nbG9iYWwudXBwZXIgPSBzdHJpbmcyLnVwcGVyO1xuc3RyaW5nMi5zdGFydHNXaXRoID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3Qgc3RyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChzdHIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAocHJlZml4LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gc3RyLmRhdGEuc3RhcnRzV2l0aChwcmVmaXguZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG59O1xuc3RyaW5nMi5zdGFydHNXaXRoLmFyaXR5ID0gMjtcbmNvbnN0IGFycmF5ID0ge307XG5hcnJheS5qb2luID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgYnVmID0gXCJcIjtcbiAgbGV0IG5lZWRTZXAgPSBmYWxzZTtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChuZWVkU2VwKSB7XG4gICAgICBidWYgKz0gc2VwLmRhdGE7XG4gICAgfVxuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGJ1ZiArPSBcIlwiLmNvbmNhdChlbGVtLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuZWVkU2VwID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bGxcIikge1xuICAgICAgICB5aWVsZCBlbGVtO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVyIG9mIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGl0ZXIudHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgICAgaWYgKCFhZGRlZC5oYXMoaXRlci5kYXRhKSkge1xuICAgICAgICAgICAgYWRkZWQuYWRkKGl0ZXIuZGF0YSk7XG4gICAgICAgICAgICB5aWVsZCBpdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB5aWVsZCBpdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuYXJyYXkudW5pcXVlLmFyaXR5ID0gMTtcbmNvbnN0IHB0ID0ge307XG5wdC50ZXh0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHRleHQpO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3Qgc2FuaXR5ID0ge307XG5zYW5pdHkucHJvamVjdElkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBhd2FpdCB0cnVlO1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbWFwcGVycyA9IFtdO1xuICBjb25zdCBkaXJlY3Rpb25zID0gW107XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBpZiAobWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiKSB7XG4gICAgICBkaXJlY3Rpb24gPSBcImRlc2NcIjtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH0gZWxzZSBpZiAobWFwcGVyLnR5cGUgPT09IFwiQXNjXCIpIHtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH1cbiAgICBtYXBwZXJzLnB1c2gobWFwcGVyKTtcbiAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgICBuKys7XG4gIH1cbiAgY29uc3QgYXV4ID0gW107XG4gIGxldCBpZHggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgY29uc3QgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xuICAgIH1cbiAgICBhdXgucHVzaCh0dXBsZSk7XG4gICAgaWR4Kys7XG4gIH1cbiAgYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiKSB7XG4gICAgICAgIGMgPSAtYztcbiAgICAgIH1cbiAgICAgIGlmIChjICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICB9KTtcbiAgcmV0dXJuIGZyb21KUyhhdXgubWFwKCh2KSA9PiB2WzBdKSk7XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXTtcbiAgY29uc3Qgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlLmRhdGEsIHsgX3Njb3JlOiB2YWx1ZVNjb3JlIH0pO1xuICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gIH1cbiAgc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpO1xuICByZXR1cm4gZnJvbUpTKHNjb3JlZCk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xuY29uc3QgZGVsdGEgPSB7fTtcbmRlbHRhLm9wZXJhdGlvbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG4gKz0gZWxlbS5kYXRhO1xuICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5zdW0uYXJpdHkgPSAxO1xubWF0aC5hdmcgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG4gPSAwO1xuICBsZXQgYyA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAoZWxlbS50eXBlID09PSBcIm51bGxcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuICs9IGVsZW0uZGF0YTtcbiAgICBjKys7XG4gIH1cbiAgaWYgKGMgPT09IDApIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKG4gLyBjKTtcbn07XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBkYXRlVGltZTIgPSB7fTtcbmRhdGVUaW1lMi5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3cyKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIHJldHVybiBmcm9tRGF0ZVRpbWUobmV3IERhdGVUaW1lKHNjb3BlLmNvbnRleHQudGltZXN0YW1wKSk7XG59O1xuZGF0ZVRpbWUyLm5vdy5hcml0eSA9IDA7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZTogZGF0ZVRpbWUyXG59O1xuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgTWFya1Byb2Nlc3NvciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZywgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInN0cmluZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtYXJrc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpbmRleFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwYXJzZU9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWxsb3dCb29zdFwiLCBmYWxzZSk7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICB9XG4gIGhhc01hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICB9XG4gIHByb2Nlc3ModmlzaXRvcikge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBoYW5kbGVyOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZygpIHtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdO1xuICAgIGNvbnN0IGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocHJldi5wb3NpdGlvbiwgY3Vyci5wb3NpdGlvbik7XG4gIH1cbiAgc2xpY2UobGVuKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XS5wb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICB9XG59XG5cbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvO1xuY29uc3QgTlVNID0gL15cXGQrLztcbmNvbnN0IElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcbmNvbnN0IFBSRUNfUEFJUiA9IDE7XG5jb25zdCBQUkVDX09SID0gMjtcbmNvbnN0IFBSRUNfQU5EID0gMztcbmNvbnN0IFBSRUNfQ09NUCA9IDQ7XG5jb25zdCBQUkVDX09SREVSID0gNDtcbmNvbnN0IFBSRUNfQUREID0gNjtcbmNvbnN0IFBSRUNfU1VCID0gNjtcbmNvbnN0IFBSRUNfTVVMID0gNztcbmNvbnN0IFBSRUNfRElWID0gNztcbmNvbnN0IFBSRUNfTU9EID0gNztcbmNvbnN0IFBSRUNfUE9XID0gODtcbmNvbnN0IFBSRUNfUE9TID0gMTA7XG5jb25zdCBQUkVDX05PVCA9IDEwO1xuY29uc3QgUFJFQ19ORUcgPSA4O1xuZnVuY3Rpb24gcGFyc2UkMShzdHIpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICByZXR1cm4gcmVzdWx0O1xuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xuICBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgbGV0IG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX1BPUyk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJwb3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibmVnXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKFwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInR1cGxlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0dXBsZV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiKVwiOiB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19OT1QpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiW1wiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImFycmF5XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmVzLnBvc2l0aW9uO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiXlwiOiB7XG4gICAgICBwb3MrKztcbiAgICAgIG1hcmtzID0gW107XG4gICAgICB3aGlsZSAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwidGhpc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIkXCI6IHtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgaWYgKGZyYWNMZW4pIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImZsb2F0XCI7XG4gICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJlXCIgfHwgc3RyW3Bvc10gPT09IFwiRVwiKSB7XG4gICAgICAgICAgbmFtZSA9IFwic2NpXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IG5hbWUgKyBcIl9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgY2FzZSBcIihcIjoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aGlzX2F0dHJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgbGV0IGxoc0xldmVsID0gMTI7XG4gIGxldCB0cmF2O1xuICBsb29wOlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKTtcbiAgICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInRyYXZlcnNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSB0cmF2LnBvc2l0aW9uO1xuICAgICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInRyYXZlcnNhbF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgdG9rZW4yID0gc3RyW2lubmVyUG9zXTtcbiAgICAgIHN3aXRjaCAodG9rZW4yKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICBsZXQgbmV4dFRva2VuID0gc3RyW2lubmVyUG9zICsgMV07XG4gICAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19QQUlSIHx8IGxoc0xldmVsIDw9IFBSRUNfUEFJUilcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGFpclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BBSVI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIj1cIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSk7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIitcIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQUREIHx8IGxoc0xldmVsIDwgUFJFQ19BREQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFkZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfU1VCIHx8IGxoc0xldmVsIDwgUFJFQ19TVUIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIipcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUE9XIHx8IGxoc0xldmVsIDw9IFBSRUNfUE9XKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJoczIgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BPVyk7XG4gICAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByaHMyO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwb3dcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgcG9zID0gcmhzMi5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QT1c7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NVUwgfHwgbGhzTGV2ZWwgPCBQUkVDX01VTClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiL1wiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19ESVYgfHwgbGhzTGV2ZWwgPCBQUkVDX0RJVilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiJVwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NT0QgfHwgbGhzTGV2ZWwgPCBQUkVDX01PRClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibW9kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IG5leHRQb3MgPSBpbm5lclBvcyArIDE7XG4gICAgICAgICAgaWYgKHN0cltuZXh0UG9zXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIG5leHRQb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSk7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInxcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1IgfHwgbGhzTGV2ZWwgPCBQUkVDX09SKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfT1IgKyAxKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm9yXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSlcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XG4gICAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGlwZWNhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCImXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0FORCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFuZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BTkQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiFcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KTtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZFwiOiB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkZXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDQ7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBsZXQgaWRlbnQgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKTtcbiAgICAgICAgICBzd2l0Y2ggKGlkZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5cIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICAgIGxldCBpc0dyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiaW5fcmFuZ2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH0sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyA1IH0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBsZXQgZmFpbFBvc2l0aW9uID0gKHRyYXYgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYXYudHlwZSkgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbiB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBsZXQgaWRlbnRTdGFydCA9IHBvcztcbiAgICAgIGxldCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoIWlkZW50TGVuMilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBwb3MgKz0gaWRlbnRMZW4yO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcImF0dHJfYWNjZXNzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRTdGFydCB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcImRlcmVmXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzLnB1c2goXG4gICAgICAgICAgeyBuYW1lOiBcImRlcmVmX2F0dHJcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICB0eXBlID0gXCJleGNfcmFuZ2VcIjtcbiAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfVxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwic3F1YXJlX2JyYWNrZXRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInxcIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2NhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICBpZiAoc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIoXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBwb3MrKztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICB9IGVsc2Uge1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgbGV0IGxhc3RQb3MgPSBwb3M7XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICBsYXN0UG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKVwiKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfYXJnc19lbmRcIiwgcG9zaXRpb246IGxhc3RQb3MgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwib2JqZWN0XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB3aGlsZSAoc3RyW3Bvc10gIT09IFwifVwiKSB7XG4gICAgICBsZXQgcGFpclBvcyA9IHBvcztcbiAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIn1cIiAmJiBzdHJbcG9zXSAhPT0gXCIsXCIpIHtcbiAgICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpO1xuICAgICAgICAgIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0X3RoaXNcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICBsZXQgbmV4dFBvcyA9IHNraXBXUyhzdHIsIGV4cHIucG9zaXRpb24pO1xuICAgICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSBcInN0clwiICYmIHN0cltuZXh0UG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3BhaXJcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcywgdmFsdWUubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHZhbHVlLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogXCJvYmplY3RfZXhwclwiLCBwb3NpdGlvbjogcG9zIH0sIGV4cHIubWFya3MpO1xuICAgICAgICAgIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIHBvcysrO1xuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgc3RyOlxuICAgIGZvciAoOyA7IHBvcysrKSB7XG4gICAgICBpZiAocG9zID4gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgYnJlYWsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSBcInVcIikge1xuICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHN0ci5pbmRleE9mKFwifVwiLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMiB9KTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyA2IH0pO1xuICAgICAgICAgICAgICBwb3MgKz0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic2luZ2xlX2VzY2FwZVwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfc3RhcnRcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gKGJhc2UpID0+IGIoYShiYXNlKSk7XG59XG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIk1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiRmxhdE1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQobWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogXCJcXG5cIixcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FRdWVyeUVycm9yXCIpO1xuICB9XG59XG5jb25zdCBFWFBSX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICBjb25zdCBpbm5lciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBpbm5lclxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICBjb25zdCBuZXh0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiBuZXh0Lm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCB0cmF2ZXJzYWxMaXN0ID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiKSB7XG4gICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XG4gICAgfVxuICAgIGlmIChiYXNlLnR5cGUgPT09IFwiRXZlcnl0aGluZ1wiIHx8IGJhc2UudHlwZSA9PT0gXCJBcnJheVwiIHx8IGJhc2UudHlwZSA9PT0gXCJQaXBlRnVuY0NhbGxcIikge1xuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheSgodmFsKSA9PiB2YWwsIHRyYXZlcnNhbCk7XG4gICAgfVxuICAgIGlmICh0cmF2ZXJzYWwgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IHVuZXhwZWN0ZWQgZW1wdHkgdHJhdmVyc2FsXCIpO1xuICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lID09PSBcIm51bGxcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTmVnXCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9zXCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCItXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtdWwocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIlXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBwb3cocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBvcCA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGluX3JhbmdlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDpcbiAgICAgIHdoaWxlIChwLmhhc01hcmsoKSkge1xuICAgICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInN0cl9lbmRcIjpcbiAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBjYXNlIFwic3RyX3BhdXNlXCI6XG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJfc3RhcnRcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzaW5nbGVfZXNjYXBlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgdmFsdWUgKz0gRVNDQVBFX1NFUVVFTkNFW2NoYXJdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ1bmljb2RlX2hleFwiOlxuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG1hcms6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBzY2kocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIikge1xuICAgICAgbGV0IGlzU3BsYXQgPSBmYWxzZTtcbiAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIpIHtcbiAgICAgICAgaXNTcGxhdCA9IHRydWU7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXJyYXlcIixcbiAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0dXBsZV9lbmRcIikge1xuICAgICAgbWVtYmVycy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlR1cGxlXCIsXG4gICAgICBtZW1iZXJzXG4gICAgfTtcbiAgfSxcbiAgZnVuY19jYWxsKHApIHtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgfTtcbiAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5mYWxsYmFjayA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XG4gICAgICBpZiAoYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpKSB7XG4gICAgICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogXCJTZWxlY3RvclwiIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSkge1xuICAgICAgaWYgKHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICAgIGtleTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkgIT09IHZvaWQgMCkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIG5hbWVzcGFjZTogXCIuY29uY2F0KG5hbWVzcGFjZSkpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGNvbnN0IG9sZEFsbG93Qm9vc3QgPSBwLmFsbG93Qm9vc3Q7XG4gICAgaWYgKG5hbWUgPT09IFwic2NvcmVcIikge1xuICAgICAgcC5hbGxvd0Jvb3N0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBjb25zdCBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICBpZiAobWFya05hbWUgPT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwib3JkZXJcIikge1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogXCJBc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT09IFwiZGVzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiRGVzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgY29uc3QgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkpIHtcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXNjXCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGNvbnN0IHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdChwKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXRfdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgIChiYXNlKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIkZpbHRlclwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBleHByXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0XG4gICAgKTtcbiAgfSxcbiAgc2xpY2UocCkge1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiAocmhzKSA9PiB0cmF2ZXJzZUFycmF5KFxuICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICAgIGlzSW5jbHVzaXZlXG4gICAgICB9KSxcbiAgICAgIHJoc1xuICAgICk7XG4gIH0sXG4gIHByb2plY3Rpb24ocCkge1xuICAgIGNvbnN0IG9iaiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUHJvamVjdGlvbigoYmFzZSkgPT4gKHsgdHlwZTogXCJQcm9qZWN0aW9uXCIsIGJhc2UsIGV4cHI6IG9iaiB9KSwgcmlnaHQpO1xuICB9LFxuICBhdHRyX2FjY2VzcyhwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWUgfSksIHJpZ2h0KTtcbiAgfSxcbiAgZGVyZWYocCkge1xuICAgIGxldCBhdHRyID0gbnVsbDtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJkZXJlZl9hdHRyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGF0dHIgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcCA9IChiYXNlKSA9PiBhdHRyID8geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oXG4gICAgICAoYmFzZSkgPT4gd3JhcCh7XG4gICAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgICAgYmFzZVxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIGFycmF5X3Bvc3RmaXgocCkge1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7IHR5cGU6IFwiQXJyYXlDb2VyY2VcIiwgYmFzZSB9KSwgcmlnaHQpO1xuICB9XG59O1xuY29uc3QgU0VMRUNUT1JfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xuICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgIGNvbnN0IGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFpcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFuZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9yKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbm90KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXNjKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGVzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQWNjZXNzQXR0cmlidXRlXCIgJiYgIW5vZGUuYmFzZSkge1xuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJEZXJlZlwiIHx8IG5vZGUudHlwZSA9PT0gXCJNYXBcIiB8fCBub2RlLnR5cGUgPT09IFwiUHJvamVjdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTbGljZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJGaWx0ZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiQWNjZXNzRWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheUNvZXJjZVwiKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlLmJhc2UpO1xuICB9XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkNhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiBcIi5jb25jYXQobm9kZS50eXBlKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGFyaXR5LCBjb3VudCkge1xuICBpZiAodHlwZW9mIGFyaXR5ID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50ICE9PSBhcml0eSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFxuICAgICAgICBcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLiBFeHBlY3RlZCBcIikuY29uY2F0KGFyaXR5LCBcIiwgZ290IFwiKS5jb25jYXQoY291bnQsIFwiLlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJpdHkpIHtcbiAgICBpZiAoIWFyaXR5KGNvdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gXCIuY29uY2F0KG5hbWUsIFwiKCkuXCIpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIGZ1bmN0aW9uTmFtZSwgYXJnQ291bnQpIHtcbiAgY29uc3QgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzID0gW1wiY2hhbmdlZEFueVwiLCBcImNoYW5nZWRPbmx5XCJdO1xuICByZXR1cm4gbmFtZXNwYWNlID09IFwiZGlmZlwiICYmIGFyZ0NvdW50ID09IDIgJiYgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzLmluY2x1ZGVzKGZ1bmN0aW9uTmFtZSk7XG59XG5jbGFzcyBHcm9xU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uKSB7XG4gICAgc3VwZXIoXCJTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiBcIi5jb25jYXQocG9zaXRpb24pKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicG9zaXRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJHcm9xU3ludGF4RXJyb3JcIik7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgIHRocm93IG5ldyBHcm9xU3ludGF4RXJyb3IocmVzdWx0LnBvc2l0aW9uKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHByb2Nlc3Nvci5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59XG5cbmV4cG9ydCB7IERhdGVUaW1lLCBQYXRoLCBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLCBwYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9MS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = { timeout: isReactNative ? 6e4 : 12e4 };\nconst processOptions = function processOptions2(opts) {\n  const options = {\n    ...defaultOptions,\n    ...typeof opts === \"string\" ? { url: opts } : opts\n  };\n  const { searchParams } = new URL(options.url, \"http://localhost\");\n  options.timeout = normalizeTimeout(options.timeout);\n  if (options.query) {\n    for (const [key, value] of Object.entries(options.query)) {\n      if (value !== void 0) {\n        if (Array.isArray(value)) {\n          for (const v of value) {\n            searchParams.append(key, v);\n          }\n        } else {\n          searchParams.append(key, value);\n        }\n      }\n    }\n  }\n  const [url] = options.url.split(\"?\");\n  const search = searchParams.toString();\n  if (search) {\n    options.url = \"\".concat(url, \"?\").concat(search);\n  }\n  options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n  return options;\n};\nfunction normalizeTimeout(time) {\n  if (time === false || time === 0) {\n    return false;\n  }\n  if (time.connect || time.socket) {\n    return time;\n  }\n  const delay = Number(time);\n  if (isNaN(delay)) {\n    return normalizeTimeout(defaultOptions.timeout);\n  }\n  return { connect: delay, socket: delay };\n}\n\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n  if (!validUrl.test(options.url)) {\n    throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n  }\n};\n\nexports.processOptions = processOptions;\nexports.validateOptions = validateOptions;\n//# sourceMappingURL=defaultOptionsValidator-n1t8zknB.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1uMXQ4emtuQi5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFsdG9yLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItbjF0OHprbkIuY2pzP2JmYWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0geyB0aW1lb3V0OiBpc1JlYWN0TmF0aXZlID8gNmU0IDogMTJlNCB9O1xuY29uc3QgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uczIob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLnR5cGVvZiBvcHRzID09PSBcInN0cmluZ1wiID8geyB1cmw6IG9wdHMgfSA6IG9wdHNcbiAgfTtcbiAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwob3B0aW9ucy51cmwsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgb3B0aW9ucy50aW1lb3V0ID0gbm9ybWFsaXplVGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuICBpZiAob3B0aW9ucy5xdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBbdXJsXSA9IG9wdGlvbnMudXJsLnNwbGl0KFwiP1wiKTtcbiAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gIGlmIChzZWFyY2gpIHtcbiAgICBvcHRpb25zLnVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/XCIpLmNvbmNhdChzZWFyY2gpO1xuICB9XG4gIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5ib2R5ICYmICFvcHRpb25zLm1ldGhvZCA/IFwiUE9TVFwiIDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVvdXQodGltZSkge1xuICBpZiAodGltZSA9PT0gZmFsc2UgfHwgdGltZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGltZS5jb25uZWN0IHx8IHRpbWUuc29ja2V0KSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGltZSk7XG4gIGlmIChpc05hTihkZWxheSkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVGltZW91dChkZWZhdWx0T3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICByZXR1cm4geyBjb25uZWN0OiBkZWxheSwgc29ja2V0OiBkZWxheSB9O1xufVxuXG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuY29uc3QgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zMihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJy5jb25jYXQob3B0aW9ucy51cmwsICdcIiBpcyBub3QgYSB2YWxpZCBVUkwnKSk7XG4gIH1cbn07XG5cbmV4cG9ydHMucHJvY2Vzc09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucztcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gdmFsaWRhdGVPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItbjF0OHprbkIuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/get-it/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-n1t8zknB.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs\");\nvar decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\");\nvar follow = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar toStream = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\");\nvar isStream = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/is-stream/index.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar qs = __webpack_require__(/*! querystring */ \"querystring\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\n\nfunction _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }\n\nfunction _interopNamespaceCompat(e) {\n  if (e && typeof e === 'object' && 'default' in e) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar decompressResponse__default = /*#__PURE__*/_interopDefaultCompat(decompressResponse);\nvar follow__default = /*#__PURE__*/_interopDefaultCompat(follow);\nvar http__default = /*#__PURE__*/_interopDefaultCompat(http);\nvar https__default = /*#__PURE__*/_interopDefaultCompat(https);\nvar toStream__default = /*#__PURE__*/_interopDefaultCompat(toStream);\nvar isStream__default = /*#__PURE__*/_interopDefaultCompat(isStream);\nvar progressStream__default = /*#__PURE__*/_interopDefaultCompat(progressStream);\nvar qs__default = /*#__PURE__*/_interopDefaultCompat(qs);\nvar url__default = /*#__PURE__*/_interopDefaultCompat(url);\nvar tunnel__namespace = /*#__PURE__*/_interopNamespaceCompat(tunnel);\n\nconst middlewareReducer = (middleware) => function applyMiddleware(hook, defaultValue, ...args) {\n  const bailEarly = hook === \"onError\";\n  let value = defaultValue;\n  for (let i = 0; i < middleware[hook].length; i++) {\n    const handler = middleware[hook][i];\n    value = handler(value, ...args);\n    if (bailEarly && !value) {\n      break;\n    }\n  }\n  return value;\n};\n\nfunction createPubSub() {\n  const subscribers = /* @__PURE__ */ Object.create(null);\n  let nextId = 0;\n  function subscribe(subscriber) {\n    const id = nextId++;\n    subscribers[id] = subscriber;\n    return function unsubscribe() {\n      delete subscribers[id];\n    };\n  }\n  function publish(event) {\n    for (const id in subscribers) {\n      subscribers[id](event);\n    }\n  }\n  return {\n    publish,\n    subscribe\n  };\n}\n\nconst channelNames = [\n  \"request\",\n  \"response\",\n  \"progress\",\n  \"error\",\n  \"abort\"\n];\nconst middlehooks = [\n  \"processOptions\",\n  \"validateOptions\",\n  \"interceptRequest\",\n  \"finalizeOptions\",\n  \"onRequest\",\n  \"onResponse\",\n  \"onError\",\n  \"onReturn\",\n  \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n  const loadedMiddleware = [];\n  const middleware = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || [];\n      return ware;\n    },\n    {\n      processOptions: [defaultOptionsValidator.processOptions],\n      validateOptions: [defaultOptionsValidator.validateOptions]\n    }\n  );\n  function request(opts) {\n    const onResponse = (reqErr, res, ctx) => {\n      let error = reqErr;\n      let response = res;\n      if (!error) {\n        try {\n          response = applyMiddleware(\"onResponse\", res, ctx);\n        } catch (err) {\n          response = null;\n          error = err;\n        }\n      }\n      error = error && applyMiddleware(\"onError\", error, ctx);\n      if (error) {\n        channels.error.publish(error);\n      } else if (response) {\n        channels.response.publish(response);\n      }\n    };\n    const channels = channelNames.reduce((target, name) => {\n      target[name] = createPubSub();\n      return target;\n    }, {});\n    const applyMiddleware = middlewareReducer(middleware);\n    const options = applyMiddleware(\"processOptions\", opts);\n    applyMiddleware(\"validateOptions\", options);\n    const context = { options, channels, applyMiddleware };\n    let ongoingRequest;\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));\n    });\n    channels.abort.subscribe(() => {\n      unsubscribe();\n      if (ongoingRequest) {\n        ongoingRequest.abort();\n      }\n    });\n    const returnValue = applyMiddleware(\"onReturn\", channels, context);\n    if (returnValue === channels) {\n      channels.request.publish(context);\n    }\n    return returnValue;\n  }\n  request.use = function use(newMiddleware) {\n    if (!newMiddleware) {\n      throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    }\n    if (typeof newMiddleware === \"function\") {\n      throw new Error(\n        \"Tried to add middleware that was a function. It probably expects you to pass options to it.\"\n      );\n    }\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        \"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\"\n      );\n    }\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key]);\n      }\n    });\n    loadedMiddleware.push(newMiddleware);\n    return request;\n  };\n  request.clone = () => createRequester(loadedMiddleware, httpRequest);\n  initMiddleware.forEach(request.use);\n  return request;\n}\n\nfunction lowerCaseHeaders(headers) {\n  return Object.keys(headers || {}).reduce((acc, header) => {\n    acc[header.toLowerCase()] = headers[header];\n    return acc;\n  }, {});\n}\n\nfunction formatHostname(hostname) {\n  return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n  const zone = zoneStr.trim().toLowerCase();\n  const zoneParts = zone.split(\":\", 2);\n  const zoneHost = formatHostname(zoneParts[0]);\n  const zonePort = zoneParts[1];\n  const hasPort = zone.indexOf(\":\") > -1;\n  return { hostname: zoneHost, port: zonePort, hasPort };\n}\nfunction uriInNoProxy(uri, noProxy) {\n  const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n  const hostname = formatHostname(uri.hostname);\n  const noProxyList = noProxy.split(\",\");\n  return noProxyList.map(parseNoProxyZone).some((noProxyZone) => {\n    const isMatchedAt = hostname.indexOf(noProxyZone.hostname);\n    const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n    if (noProxyZone.hasPort) {\n      return port === noProxyZone.port && hostnameMatched;\n    }\n    return hostnameMatched;\n  });\n}\nfunction getProxyFromUri(uri) {\n  const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n  if (noProxy === \"*\") {\n    return null;\n  }\n  if (noProxy !== \"\" && uriInNoProxy(uri, noProxy)) {\n    return null;\n  }\n  if (uri.protocol === \"http:\") {\n    return process.env.HTTP_PROXY || process.env.http_proxy || null;\n  }\n  if (uri.protocol === \"https:\") {\n    return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;\n  }\n  return null;\n}\nfunction getHostFromUri(uri) {\n  let host = uri.host;\n  if (uri.port) {\n    if (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") {\n      host = uri.hostname;\n    }\n  }\n  return host;\n}\nfunction getHostHeaderWithPort(uri) {\n  const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n  return \"\".concat(uri.hostname, \":\").concat(port);\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n  const headers = reqOpts.headers || {};\n  const options = Object.assign({}, reqOpts, { headers });\n  headers.host = headers.host || getHostHeaderWithPort(uri);\n  options.protocol = proxy.protocol || options.protocol;\n  options.hostname = proxy.host.replace(/:\\d+/, \"\");\n  options.port = proxy.port;\n  options.host = getHostFromUri(Object.assign({}, uri, proxy));\n  options.href = \"\".concat(options.protocol, \"//\").concat(options.host).concat(options.path);\n  options.path = url__default.default.format(uri);\n  return options;\n}\nfunction getProxyOptions(options) {\n  let proxy;\n  if (options.hasOwnProperty(\"proxy\")) {\n    proxy = options.proxy;\n  } else {\n    const uri = url__default.default.parse(options.url);\n    proxy = getProxyFromUri(uri);\n  }\n  return typeof proxy === \"string\" ? url__default.default.parse(proxy) : proxy;\n}\n\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nfunction concat(stream, cb) {\n  const chunks = [];\n  stream.on(\"data\", function(chunk) {\n    chunks.push(chunk);\n  });\n  stream.once(\"end\", function() {\n    if (cb)\n      cb(null, Buffer.concat(chunks));\n    cb = null;\n  });\n  stream.once(\"error\", function(err) {\n    if (cb)\n      cb(err);\n    cb = null;\n  });\n}\n\nfunction timedOut(req, time) {\n  if (req.timeoutTimer) {\n    return req;\n  }\n  const delays = isNaN(time) ? time : { socket: time, connect: time };\n  const hostHeader = req.getHeader(\"host\");\n  const host = hostHeader ? \" to \" + hostHeader : \"\";\n  if (delays.connect !== void 0) {\n    req.timeoutTimer = setTimeout(function timeoutHandler() {\n      req.abort();\n      const e = new Error(\"Connection timed out on request\" + host);\n      e.code = \"ETIMEDOUT\";\n      req.emit(\"error\", e);\n    }, delays.connect);\n  }\n  req.on(\"socket\", function assign(socket) {\n    if (!(socket.connecting || socket._connecting)) {\n      connect();\n      return;\n    }\n    socket.once(\"connect\", connect);\n  });\n  function clear() {\n    if (req.timeoutTimer) {\n      clearTimeout(req.timeoutTimer);\n      req.timeoutTimer = null;\n    }\n  }\n  function connect() {\n    clear();\n    if (delays.socket !== void 0) {\n      req.setTimeout(delays.socket, function socketTimeoutHandler() {\n        req.abort();\n        const e = new Error(\"Socket timed out on request\" + host);\n        e.code = \"ESOCKETTIMEDOUT\";\n        req.emit(\"error\", e);\n      });\n    }\n  }\n  return req.on(\"error\", clear);\n}\n\nconst uriParts = [\n  \"protocol\",\n  \"slashes\",\n  \"auth\",\n  \"host\",\n  \"port\",\n  \"hostname\",\n  \"hash\",\n  \"search\",\n  \"query\",\n  \"pathname\",\n  \"path\",\n  \"href\"\n];\nconst defaultProxyHeaderWhiteList = [\n  \"accept\",\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"accept-language\",\n  \"accept-ranges\",\n  \"cache-control\",\n  \"content-encoding\",\n  \"content-language\",\n  \"content-location\",\n  \"content-md5\",\n  \"content-range\",\n  \"content-type\",\n  \"connection\",\n  \"date\",\n  \"expect\",\n  \"max-forwards\",\n  \"pragma\",\n  \"referer\",\n  \"te\",\n  \"user-agent\",\n  \"via\"\n];\nconst defaultProxyHeaderExclusiveList = [\"proxy-authorization\"];\nfunction shouldEnable(options) {\n  if (typeof options.tunnel !== \"undefined\") {\n    return Boolean(options.tunnel);\n  }\n  const uri = url__default.default.parse(options.url);\n  if (uri.protocol === \"https:\") {\n    return true;\n  }\n  return false;\n}\nfunction applyAgent(opts = {}, proxy) {\n  const options = Object.assign({}, opts);\n  const proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header) => header.toLowerCase());\n  const proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header) => header.toLowerCase());\n  const proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n  proxyHeaders.host = constructProxyHost(options);\n  options.headers = Object.keys(options.headers || {}).reduce((headers, header) => {\n    const isAllowed = proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1;\n    if (isAllowed) {\n      headers[header] = options.headers[header];\n    }\n    return headers;\n  }, {});\n  const tunnelFn = getTunnelFn(options, proxy);\n  const tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n  options.agent = tunnelFn(tunnelOptions);\n  return options;\n}\nfunction getTunnelFn(options, proxy) {\n  const uri = getUriParts(options);\n  const tunnelFnName = constructTunnelFnName(uri, proxy);\n  return tunnel__namespace[tunnelFnName];\n}\nfunction getUriParts(options) {\n  return uriParts.reduce((uri, part) => {\n    uri[part] = options[part];\n    return uri;\n  }, {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n  const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\";\n  const proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n  return \"\".concat(uriProtocol, \"Over\").concat(proxyProtocol);\n}\nfunction constructProxyHost(uri) {\n  const port = uri.port;\n  const protocol = uri.protocol;\n  let proxyHost = \"\".concat(uri.hostname, \":\");\n  if (port) {\n    proxyHost += port;\n  } else if (protocol === \"https:\") {\n    proxyHost += \"443\";\n  } else {\n    proxyHost += \"80\";\n  }\n  return proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n  return Object.keys(headers).filter((header) => whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header) => {\n    set[header] = headers[header];\n    return set;\n  }, {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n  return {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders\n    },\n    headers: options.headers,\n    ca: options.ca,\n    cert: options.cert,\n    key: options.key,\n    passphrase: options.passphrase,\n    pfx: options.pfx,\n    ciphers: options.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized,\n    secureOptions: options.secureOptions,\n    secureProtocol: options.secureProtocol\n  };\n}\n\nconst adapter = \"node\";\nconst reduceResponse = (res, reqUrl, method, body) => ({\n  body,\n  url: reqUrl,\n  method,\n  headers: res.headers,\n  statusCode: res.statusCode,\n  statusMessage: res.statusMessage\n});\nconst httpRequester = (context, cb) => {\n  const { options } = context;\n  const uri = Object.assign({}, url__default.default.parse(options.url));\n  if (typeof fetch === \"function\" && options.fetch) {\n    const controller = new AbortController();\n    const reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n      ...uri,\n      method: options.method,\n      headers: {\n        ...typeof options.fetch === \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n        ...lowerCaseHeaders(options.headers)\n      },\n      maxRedirects: options.maxRedirects\n    });\n    const fetchOpts = {\n      credentials: options.withCredentials ? \"include\" : \"omit\",\n      ...typeof options.fetch === \"object\" ? options.fetch : {},\n      method: reqOpts2.method,\n      headers: reqOpts2.headers,\n      body: options.body,\n      signal: controller.signal\n    };\n    const injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n      adapter,\n      context\n    });\n    if (injectedResponse2) {\n      const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n      const cancel = () => clearTimeout(cbTimer);\n      return { abort: cancel };\n    }\n    const request2 = fetch(options.url, fetchOpts);\n    context.applyMiddleware(\"onRequest\", { options, adapter, request: request2, context });\n    request2.then(async (res) => {\n      const body = options.rawBody ? res.body : await res.text();\n      const headers = {};\n      res.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n      cb(null, {\n        body,\n        url: res.url,\n        method: options.method,\n        headers,\n        statusCode: res.status,\n        statusMessage: res.statusText\n      });\n    }).catch((err) => {\n      if (err.name == \"AbortError\")\n        return;\n      cb(err);\n    });\n    return { abort: () => controller.abort() };\n  }\n  const bodyType = isStream__default.default(options.body) ? \"stream\" : typeof options.body;\n  if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body)) {\n    throw new Error(\"Request body must be a string, buffer or stream, got \".concat(bodyType));\n  }\n  const lengthHeader = {};\n  if (options.bodySize) {\n    lengthHeader[\"content-length\"] = options.bodySize;\n  } else if (options.body && bodyType !== \"stream\") {\n    lengthHeader[\"content-length\"] = Buffer.byteLength(options.body);\n  }\n  let aborted = false;\n  const callback = (err, res) => !aborted && cb(err, res);\n  context.channels.abort.subscribe(() => {\n    aborted = true;\n  });\n  let reqOpts = Object.assign({}, uri, {\n    method: options.method,\n    headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n    maxRedirects: options.maxRedirects\n  });\n  const proxy = getProxyOptions(options);\n  const tunnel = proxy && shouldEnable(options);\n  const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n    adapter,\n    context\n  });\n  if (injectedResponse) {\n    const cbTimer = setImmediate(callback, null, injectedResponse);\n    const abort = () => clearImmediate(cbTimer);\n    return { abort };\n  }\n  if (options.maxRedirects !== 0) {\n    reqOpts.maxRedirects = options.maxRedirects || 5;\n  }\n  if (proxy && tunnel) {\n    reqOpts = applyAgent(reqOpts, proxy);\n  } else if (proxy && !tunnel) {\n    reqOpts = rewriteUriForProxy(reqOpts, uri, proxy);\n  }\n  if (!tunnel && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n    const [username, password] = proxy.auth.username ? [proxy.auth.username, proxy.auth.password] : proxy.auth.split(\":\").map((item) => qs__default.default.unescape(item));\n    const auth = Buffer.from(\"\".concat(username, \":\").concat(password), \"utf8\");\n    const authBase64 = auth.toString(\"base64\");\n    reqOpts.headers[\"proxy-authorization\"] = \"Basic \".concat(authBase64);\n  }\n  const transport = getRequestTransport(reqOpts, proxy, tunnel);\n  if (typeof options.debug === \"function\" && proxy) {\n    options.debug(\n      \"Proxying using %s\",\n      reqOpts.agent ? \"tunnel agent\" : \"\".concat(reqOpts.host, \":\").concat(reqOpts.port)\n    );\n  }\n  const tryCompressed = reqOpts.method !== \"HEAD\";\n  if (tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== false) {\n    reqOpts.headers[\"accept-encoding\"] = \"br, gzip, deflate\";\n  }\n  const finalOptions = context.applyMiddleware(\n    \"finalizeOptions\",\n    reqOpts\n  );\n  const request = transport.request(finalOptions, (response) => {\n    const res = tryCompressed ? decompressResponse__default.default(response) : response;\n    const resStream = context.applyMiddleware(\"onHeaders\", res, {\n      headers: response.headers,\n      adapter,\n      context\n    });\n    const reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n    if (options.stream) {\n      callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n      return;\n    }\n    concat(resStream, (err, data) => {\n      if (err) {\n        return callback(err);\n      }\n      const body = options.rawBody ? data : data.toString();\n      const reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n      return callback(null, reduced);\n    });\n  });\n  if (options.timeout) {\n    timedOut(request, options.timeout);\n  }\n  request.once(\"error\", callback);\n  const { bodyStream, progress } = getProgressStream(options);\n  context.applyMiddleware(\"onRequest\", { options, adapter, request, context, progress });\n  if (bodyStream) {\n    bodyStream.pipe(request);\n  } else {\n    request.end(options.body);\n  }\n  return { abort: () => request.abort() };\n};\nfunction getProgressStream(options) {\n  if (!options.body) {\n    return {};\n  }\n  const bodyIsStream = isStream__default.default(options.body);\n  const length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n  if (!length) {\n    return bodyIsStream ? { bodyStream: options.body } : {};\n  }\n  const progress = progressStream__default.default({ time: 16, length });\n  const bodyStream = bodyIsStream ? options.body : toStream__default.default(options.body);\n  return { bodyStream: bodyStream.pipe(progress), progress };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel) {\n  const isHttpsRequest = reqOpts.protocol === \"https:\";\n  const transports = reqOpts.maxRedirects === 0 ? { http: http__default.default, https: https__default.default } : { http: follow__default.default.http, https: follow__default.default.https };\n  if (!proxy || tunnel) {\n    return isHttpsRequest ? transports.https : transports.http;\n  }\n  let isHttpsProxy = proxy.port === 443;\n  if (proxy.protocol) {\n    isHttpsProxy = /^https:?/.test(proxy.protocol);\n  }\n  return isHttpsProxy ? transports.https : transports.http;\n}\n\nconst getIt = (initMiddleware = [], httpRequest = httpRequester) => createRequester(initMiddleware, httpRequest);\nconst environment = \"node\";\n\nexports.adapter = adapter;\nexports.environment = environment;\nexports.getIt = getIt;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsOEJBQThCLG1CQUFPLENBQUMscUlBQWdEO0FBQ3RGLHlCQUF5QixtQkFBTyxDQUFDLDhFQUFxQjtBQUN0RCxhQUFhLG1CQUFPLENBQUMsd0VBQWtCO0FBQ3ZDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywwREFBVztBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDOUMsU0FBUyxtQkFBTyxDQUFDLGdDQUFhO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixhQUFhLG1CQUFPLENBQUMsZ0VBQWM7O0FBRW5DLHFDQUFxQyw0REFBNEQ7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMseUNBQXlDLDhDQUE4QztBQUN2RjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw2REFBNkQsSUFBSTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWx0b3IvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzPzY0MDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IgPSByZXF1aXJlKCcuL19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItbjF0OHprbkIuY2pzJyk7XG52YXIgZGVjb21wcmVzc1Jlc3BvbnNlID0gcmVxdWlyZSgnZGVjb21wcmVzcy1yZXNwb25zZScpO1xudmFyIGZvbGxvdyA9IHJlcXVpcmUoJ2ZvbGxvdy1yZWRpcmVjdHMnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB0b1N0cmVhbSA9IHJlcXVpcmUoJ2ludG8tc3RyZWFtJyk7XG52YXIgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbnZhciBwcm9ncmVzc1N0cmVhbSA9IHJlcXVpcmUoJ3Byb2dyZXNzLXN0cmVhbScpO1xudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciB0dW5uZWwgPSByZXF1aXJlKCd0dW5uZWwtYWdlbnQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZUNvbXBhdChlKSB7XG4gIGlmIChlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGRlY29tcHJlc3NSZXNwb25zZV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoZGVjb21wcmVzc1Jlc3BvbnNlKTtcbnZhciBmb2xsb3dfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGZvbGxvdyk7XG52YXIgaHR0cF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoaHR0cCk7XG52YXIgaHR0cHNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGh0dHBzKTtcbnZhciB0b1N0cmVhbV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQodG9TdHJlYW0pO1xudmFyIGlzU3RyZWFtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChpc1N0cmVhbSk7XG52YXIgcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHByb2dyZXNzU3RyZWFtKTtcbnZhciBxc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQocXMpO1xudmFyIHVybF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQodXJsKTtcbnZhciB0dW5uZWxfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZUNvbXBhdCh0dW5uZWwpO1xuXG5jb25zdCBtaWRkbGV3YXJlUmVkdWNlciA9IChtaWRkbGV3YXJlKSA9PiBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoaG9vaywgZGVmYXVsdFZhbHVlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGJhaWxFYXJseSA9IGhvb2sgPT09IFwib25FcnJvclwiO1xuICBsZXQgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWlkZGxld2FyZVtob29rXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBtaWRkbGV3YXJlW2hvb2tdW2ldO1xuICAgIHZhbHVlID0gaGFuZGxlcih2YWx1ZSwgLi4uYXJncyk7XG4gICAgaWYgKGJhaWxFYXJseSAmJiAhdmFsdWUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQdWJTdWIoKSB7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBuZXh0SWQgPSAwO1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgIGNvbnN0IGlkID0gbmV4dElkKys7XG4gICAgc3Vic2NyaWJlcnNbaWRdID0gc3Vic2NyaWJlcjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBkZWxldGUgc3Vic2NyaWJlcnNbaWRdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcHVibGlzaChldmVudCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gc3Vic2NyaWJlcnMpIHtcbiAgICAgIHN1YnNjcmliZXJzW2lkXShldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcHVibGlzaCxcbiAgICBzdWJzY3JpYmVcbiAgfTtcbn1cblxuY29uc3QgY2hhbm5lbE5hbWVzID0gW1xuICBcInJlcXVlc3RcIixcbiAgXCJyZXNwb25zZVwiLFxuICBcInByb2dyZXNzXCIsXG4gIFwiZXJyb3JcIixcbiAgXCJhYm9ydFwiXG5dO1xuY29uc3QgbWlkZGxlaG9va3MgPSBbXG4gIFwicHJvY2Vzc09wdGlvbnNcIixcbiAgXCJ2YWxpZGF0ZU9wdGlvbnNcIixcbiAgXCJpbnRlcmNlcHRSZXF1ZXN0XCIsXG4gIFwiZmluYWxpemVPcHRpb25zXCIsXG4gIFwib25SZXF1ZXN0XCIsXG4gIFwib25SZXNwb25zZVwiLFxuICBcIm9uRXJyb3JcIixcbiAgXCJvblJldHVyblwiLFxuICBcIm9uSGVhZGVyc1wiXG5dO1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCkge1xuICBjb25zdCBsb2FkZWRNaWRkbGV3YXJlID0gW107XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBtaWRkbGVob29rcy5yZWR1Y2UoXG4gICAgKHdhcmUsIG5hbWUpID0+IHtcbiAgICAgIHdhcmVbbmFtZV0gPSB3YXJlW25hbWVdIHx8IFtdO1xuICAgICAgcmV0dXJuIHdhcmU7XG4gICAgfSxcbiAgICB7XG4gICAgICBwcm9jZXNzT3B0aW9uczogW2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnByb2Nlc3NPcHRpb25zXSxcbiAgICAgIHZhbGlkYXRlT3B0aW9uczogW2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnZhbGlkYXRlT3B0aW9uc11cbiAgICB9XG4gICk7XG4gIGZ1bmN0aW9uIHJlcXVlc3Qob3B0cykge1xuICAgIGNvbnN0IG9uUmVzcG9uc2UgPSAocmVxRXJyLCByZXMsIGN0eCkgPT4ge1xuICAgICAgbGV0IGVycm9yID0gcmVxRXJyO1xuICAgICAgbGV0IHJlc3BvbnNlID0gcmVzO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXNwb25zZVwiLCByZXMsIGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXJyb3IgPSBlcnJvciAmJiBhcHBseU1pZGRsZXdhcmUoXCJvbkVycm9yXCIsIGVycm9yLCBjdHgpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZSkge1xuICAgICAgICBjaGFubmVscy5yZXNwb25zZS5wdWJsaXNoKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNoYW5uZWxzID0gY2hhbm5lbE5hbWVzLnJlZHVjZSgodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBjcmVhdGVQdWJTdWIoKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGFwcGx5TWlkZGxld2FyZSA9IG1pZGRsZXdhcmVSZWR1Y2VyKG1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcHBseU1pZGRsZXdhcmUoXCJwcm9jZXNzT3B0aW9uc1wiLCBvcHRzKTtcbiAgICBhcHBseU1pZGRsZXdhcmUoXCJ2YWxpZGF0ZU9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgY29uc3QgY29udGV4dCA9IHsgb3B0aW9ucywgY2hhbm5lbHMsIGFwcGx5TWlkZGxld2FyZSB9O1xuICAgIGxldCBvbmdvaW5nUmVxdWVzdDtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNoYW5uZWxzLnJlcXVlc3Quc3Vic2NyaWJlKChjdHgpID0+IHtcbiAgICAgIG9uZ29pbmdSZXF1ZXN0ID0gaHR0cFJlcXVlc3QoY3R4LCAoZXJyLCByZXMpID0+IG9uUmVzcG9uc2UoZXJyLCByZXMsIGN0eCkpO1xuICAgIH0pO1xuICAgIGNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9uZ29pbmdSZXF1ZXN0KSB7XG4gICAgICAgIG9uZ29pbmdSZXF1ZXN0LmFib3J0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJldHVyblwiLCBjaGFubmVscywgY29udGV4dCk7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cbiAgcmVxdWVzdC51c2UgPSBmdW5jdGlvbiB1c2UobmV3TWlkZGxld2FyZSkge1xuICAgIGlmICghbmV3TWlkZGxld2FyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCByZXNvbHZlZCB0byBmYWxzZXkgdmFsdWVcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3TWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCB3YXMgYSBmdW5jdGlvbi4gSXQgcHJvYmFibHkgZXhwZWN0cyB5b3UgdG8gcGFzcyBvcHRpb25zIHRvIGl0LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobmV3TWlkZGxld2FyZS5vblJldHVybiAmJiBtaWRkbGV3YXJlLm9uUmV0dXJuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUcmllZCB0byBhZGQgbmV3IG1pZGRsZXdhcmUgd2l0aCBgb25SZXR1cm5gIGhhbmRsZXIsIGJ1dCBhbm90aGVyIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50XCJcbiAgICAgICk7XG4gICAgfVxuICAgIG1pZGRsZWhvb2tzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG5ld01pZGRsZXdhcmVba2V5XSkge1xuICAgICAgICBtaWRkbGV3YXJlW2tleV0ucHVzaChuZXdNaWRkbGV3YXJlW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxvYWRlZE1pZGRsZXdhcmUucHVzaChuZXdNaWRkbGV3YXJlKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfTtcbiAgcmVxdWVzdC5jbG9uZSA9ICgpID0+IGNyZWF0ZVJlcXVlc3Rlcihsb2FkZWRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCk7XG4gIGluaXRNaWRkbGV3YXJlLmZvckVhY2gocmVxdWVzdC51c2UpO1xuICByZXR1cm4gcmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gbG93ZXJDYXNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhoZWFkZXJzIHx8IHt9KS5yZWR1Y2UoKGFjYywgaGVhZGVyKSA9PiB7XG4gICAgYWNjW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbaGVhZGVyXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvc3RuYW1lKGhvc3RuYW1lKSB7XG4gIHJldHVybiBob3N0bmFtZS5yZXBsYWNlKC9eXFwuKi8sIFwiLlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSh6b25lU3RyKSB7XG4gIGNvbnN0IHpvbmUgPSB6b25lU3RyLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCB6b25lUGFydHMgPSB6b25lLnNwbGl0KFwiOlwiLCAyKTtcbiAgY29uc3Qgem9uZUhvc3QgPSBmb3JtYXRIb3N0bmFtZSh6b25lUGFydHNbMF0pO1xuICBjb25zdCB6b25lUG9ydCA9IHpvbmVQYXJ0c1sxXTtcbiAgY29uc3QgaGFzUG9ydCA9IHpvbmUuaW5kZXhPZihcIjpcIikgPiAtMTtcbiAgcmV0dXJuIHsgaG9zdG5hbWU6IHpvbmVIb3N0LCBwb3J0OiB6b25lUG9ydCwgaGFzUG9ydCB9O1xufVxuZnVuY3Rpb24gdXJpSW5Ob1Byb3h5KHVyaSwgbm9Qcm94eSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQgfHwgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCIpO1xuICBjb25zdCBob3N0bmFtZSA9IGZvcm1hdEhvc3RuYW1lKHVyaS5ob3N0bmFtZSk7XG4gIGNvbnN0IG5vUHJveHlMaXN0ID0gbm9Qcm94eS5zcGxpdChcIixcIik7XG4gIHJldHVybiBub1Byb3h5TGlzdC5tYXAocGFyc2VOb1Byb3h5Wm9uZSkuc29tZSgobm9Qcm94eVpvbmUpID0+IHtcbiAgICBjb25zdCBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpO1xuICAgIGNvbnN0IGhvc3RuYW1lTWF0Y2hlZCA9IGlzTWF0Y2hlZEF0ID4gLTEgJiYgaXNNYXRjaGVkQXQgPT09IGhvc3RuYW1lLmxlbmd0aCAtIG5vUHJveHlab25lLmhvc3RuYW1lLmxlbmd0aDtcbiAgICBpZiAobm9Qcm94eVpvbmUuaGFzUG9ydCkge1xuICAgICAgcmV0dXJuIHBvcnQgPT09IG5vUHJveHlab25lLnBvcnQgJiYgaG9zdG5hbWVNYXRjaGVkO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdG5hbWVNYXRjaGVkO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5RnJvbVVyaSh1cmkpIHtcbiAgY29uc3Qgbm9Qcm94eSA9IHByb2Nlc3MuZW52Lk5PX1BST1hZIHx8IHByb2Nlc3MuZW52Lm5vX3Byb3h5IHx8IFwiXCI7XG4gIGlmIChub1Byb3h5ID09PSBcIipcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChub1Byb3h5ICE9PSBcIlwiICYmIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsO1xuICB9XG4gIGlmICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRIb3N0RnJvbVVyaSh1cmkpIHtcbiAgbGV0IGhvc3QgPSB1cmkuaG9zdDtcbiAgaWYgKHVyaS5wb3J0KSB7XG4gICAgaWYgKHVyaS5wb3J0ID09PSBcIjgwXCIgJiYgdXJpLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdXJpLnBvcnQgPT09IFwiNDQzXCIgJiYgdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgICBob3N0ID0gdXJpLmhvc3RuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaG9zdDtcbn1cbmZ1bmN0aW9uIGdldEhvc3RIZWFkZXJXaXRoUG9ydCh1cmkpIHtcbiAgY29uc3QgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHVyaS5ob3N0bmFtZSwgXCI6XCIpLmNvbmNhdChwb3J0KTtcbn1cbmZ1bmN0aW9uIHJld3JpdGVVcmlGb3JQcm94eShyZXFPcHRzLCB1cmksIHByb3h5KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSByZXFPcHRzLmhlYWRlcnMgfHwge307XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXFPcHRzLCB7IGhlYWRlcnMgfSk7XG4gIGhlYWRlcnMuaG9zdCA9IGhlYWRlcnMuaG9zdCB8fCBnZXRIb3N0SGVhZGVyV2l0aFBvcnQodXJpKTtcbiAgb3B0aW9ucy5wcm90b2NvbCA9IHByb3h5LnByb3RvY29sIHx8IG9wdGlvbnMucHJvdG9jb2w7XG4gIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0LnJlcGxhY2UoLzpcXGQrLywgXCJcIik7XG4gIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnQ7XG4gIG9wdGlvbnMuaG9zdCA9IGdldEhvc3RGcm9tVXJpKE9iamVjdC5hc3NpZ24oe30sIHVyaSwgcHJveHkpKTtcbiAgb3B0aW9ucy5ocmVmID0gXCJcIi5jb25jYXQob3B0aW9ucy5wcm90b2NvbCwgXCIvL1wiKS5jb25jYXQob3B0aW9ucy5ob3N0KS5jb25jYXQob3B0aW9ucy5wYXRoKTtcbiAgb3B0aW9ucy5wYXRoID0gdXJsX19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0KHVyaSk7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IHByb3h5O1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInByb3h5XCIpKSB7XG4gICAgcHJveHkgPSBvcHRpb25zLnByb3h5O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHVyaSA9IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKG9wdGlvbnMudXJsKTtcbiAgICBwcm94eSA9IGdldFByb3h5RnJvbVVyaSh1cmkpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgcHJveHkgPT09IFwic3RyaW5nXCIgPyB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShwcm94eSkgOiBwcm94eTtcbn1cblxuLyohIHNpbXBsZS1jb25jYXQuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmZ1bmN0aW9uIGNvbmNhdChzdHJlYW0sIGNiKSB7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBzdHJlYW0ub24oXCJkYXRhXCIsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICB9KTtcbiAgc3RyZWFtLm9uY2UoXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKGNiKVxuICAgICAgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICBjYiA9IG51bGw7XG4gIH0pO1xuICBzdHJlYW0ub25jZShcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChjYilcbiAgICAgIGNiKGVycik7XG4gICAgY2IgPSBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdGltZWRPdXQocmVxLCB0aW1lKSB7XG4gIGlmIChyZXEudGltZW91dFRpbWVyKSB7XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuICBjb25zdCBkZWxheXMgPSBpc05hTih0aW1lKSA/IHRpbWUgOiB7IHNvY2tldDogdGltZSwgY29ubmVjdDogdGltZSB9O1xuICBjb25zdCBob3N0SGVhZGVyID0gcmVxLmdldEhlYWRlcihcImhvc3RcIik7XG4gIGNvbnN0IGhvc3QgPSBob3N0SGVhZGVyID8gXCIgdG8gXCIgKyBob3N0SGVhZGVyIDogXCJcIjtcbiAgaWYgKGRlbGF5cy5jb25uZWN0ICE9PSB2b2lkIDApIHtcbiAgICByZXEudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0SGFuZGxlcigpIHtcbiAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gdGltZWQgb3V0IG9uIHJlcXVlc3RcIiArIGhvc3QpO1xuICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgIHJlcS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgfSwgZGVsYXlzLmNvbm5lY3QpO1xuICB9XG4gIHJlcS5vbihcInNvY2tldFwiLCBmdW5jdGlvbiBhc3NpZ24oc29ja2V0KSB7XG4gICAgaWYgKCEoc29ja2V0LmNvbm5lY3RpbmcgfHwgc29ja2V0Ll9jb25uZWN0aW5nKSkge1xuICAgICAgY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzb2NrZXQub25jZShcImNvbm5lY3RcIiwgY29ubmVjdCk7XG4gIH0pO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAocmVxLnRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlcS50aW1lb3V0VGltZXIpO1xuICAgICAgcmVxLnRpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgY2xlYXIoKTtcbiAgICBpZiAoZGVsYXlzLnNvY2tldCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXEuc2V0VGltZW91dChkZWxheXMuc29ja2V0LCBmdW5jdGlvbiBzb2NrZXRUaW1lb3V0SGFuZGxlcigpIHtcbiAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXCJTb2NrZXQgdGltZWQgb3V0IG9uIHJlcXVlc3RcIiArIGhvc3QpO1xuICAgICAgICBlLmNvZGUgPSBcIkVTT0NLRVRUSU1FRE9VVFwiO1xuICAgICAgICByZXEuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXEub24oXCJlcnJvclwiLCBjbGVhcik7XG59XG5cbmNvbnN0IHVyaVBhcnRzID0gW1xuICBcInByb3RvY29sXCIsXG4gIFwic2xhc2hlc1wiLFxuICBcImF1dGhcIixcbiAgXCJob3N0XCIsXG4gIFwicG9ydFwiLFxuICBcImhvc3RuYW1lXCIsXG4gIFwiaGFzaFwiLFxuICBcInNlYXJjaFwiLFxuICBcInF1ZXJ5XCIsXG4gIFwicGF0aG5hbWVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaHJlZlwiXG5dO1xuY29uc3QgZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0ID0gW1xuICBcImFjY2VwdFwiLFxuICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gIFwiYWNjZXB0LWxhbmd1YWdlXCIsXG4gIFwiYWNjZXB0LXJhbmdlc1wiLFxuICBcImNhY2hlLWNvbnRyb2xcIixcbiAgXCJjb250ZW50LWVuY29kaW5nXCIsXG4gIFwiY29udGVudC1sYW5ndWFnZVwiLFxuICBcImNvbnRlbnQtbG9jYXRpb25cIixcbiAgXCJjb250ZW50LW1kNVwiLFxuICBcImNvbnRlbnQtcmFuZ2VcIixcbiAgXCJjb250ZW50LXR5cGVcIixcbiAgXCJjb25uZWN0aW9uXCIsXG4gIFwiZGF0ZVwiLFxuICBcImV4cGVjdFwiLFxuICBcIm1heC1mb3J3YXJkc1wiLFxuICBcInByYWdtYVwiLFxuICBcInJlZmVyZXJcIixcbiAgXCJ0ZVwiLFxuICBcInVzZXItYWdlbnRcIixcbiAgXCJ2aWFcIlxuXTtcbmNvbnN0IGRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdO1xuZnVuY3Rpb24gc2hvdWxkRW5hYmxlKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnR1bm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMudHVubmVsKTtcbiAgfVxuICBjb25zdCB1cmkgPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCk7XG4gIGlmICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhcHBseUFnZW50KG9wdHMgPSB7fSwgcHJveHkpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICBjb25zdCBwcm94eUhlYWRlcldoaXRlTGlzdCA9IGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdC5jb25jYXQob3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdCB8fCBbXSkubWFwKChoZWFkZXIpID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKTtcbiAgY29uc3QgcHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5jb25jYXQob3B0aW9ucy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgfHwgW10pLm1hcCgoaGVhZGVyKSA9PiBoZWFkZXIudG9Mb3dlckNhc2UoKSk7XG4gIGNvbnN0IHByb3h5SGVhZGVycyA9IGdldEFsbG93ZWRQcm94eUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzLCBwcm94eUhlYWRlcldoaXRlTGlzdCk7XG4gIHByb3h5SGVhZGVycy5ob3N0ID0gY29uc3RydWN0UHJveHlIb3N0KG9wdGlvbnMpO1xuICBvcHRpb25zLmhlYWRlcnMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMgfHwge30pLnJlZHVjZSgoaGVhZGVycywgaGVhZGVyKSA9PiB7XG4gICAgY29uc3QgaXNBbGxvd2VkID0gcHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMTtcbiAgICBpZiAoaXNBbGxvd2VkKSB7XG4gICAgICBoZWFkZXJzW2hlYWRlcl0gPSBvcHRpb25zLmhlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sIHt9KTtcbiAgY29uc3QgdHVubmVsRm4gPSBnZXRUdW5uZWxGbihvcHRpb25zLCBwcm94eSk7XG4gIGNvbnN0IHR1bm5lbE9wdGlvbnMgPSBjb25zdHJ1Y3RUdW5uZWxPcHRpb25zKG9wdGlvbnMsIHByb3h5LCBwcm94eUhlYWRlcnMpO1xuICBvcHRpb25zLmFnZW50ID0gdHVubmVsRm4odHVubmVsT3B0aW9ucyk7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0VHVubmVsRm4ob3B0aW9ucywgcHJveHkpIHtcbiAgY29uc3QgdXJpID0gZ2V0VXJpUGFydHMob3B0aW9ucyk7XG4gIGNvbnN0IHR1bm5lbEZuTmFtZSA9IGNvbnN0cnVjdFR1bm5lbEZuTmFtZSh1cmksIHByb3h5KTtcbiAgcmV0dXJuIHR1bm5lbF9fbmFtZXNwYWNlW3R1bm5lbEZuTmFtZV07XG59XG5mdW5jdGlvbiBnZXRVcmlQYXJ0cyhvcHRpb25zKSB7XG4gIHJldHVybiB1cmlQYXJ0cy5yZWR1Y2UoKHVyaSwgcGFydCkgPT4ge1xuICAgIHVyaVtwYXJ0XSA9IG9wdGlvbnNbcGFydF07XG4gICAgcmV0dXJuIHVyaTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpIHtcbiAgY29uc3QgdXJpUHJvdG9jb2wgPSB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcbiAgY29uc3QgcHJveHlQcm90b2NvbCA9IHByb3h5LnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCJIdHRwc1wiIDogXCJIdHRwXCI7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh1cmlQcm90b2NvbCwgXCJPdmVyXCIpLmNvbmNhdChwcm94eVByb3RvY29sKTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFByb3h5SG9zdCh1cmkpIHtcbiAgY29uc3QgcG9ydCA9IHVyaS5wb3J0O1xuICBjb25zdCBwcm90b2NvbCA9IHVyaS5wcm90b2NvbDtcbiAgbGV0IHByb3h5SG9zdCA9IFwiXCIuY29uY2F0KHVyaS5ob3N0bmFtZSwgXCI6XCIpO1xuICBpZiAocG9ydCkge1xuICAgIHByb3h5SG9zdCArPSBwb3J0O1xuICB9IGVsc2UgaWYgKHByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgcHJveHlIb3N0ICs9IFwiNDQzXCI7XG4gIH0gZWxzZSB7XG4gICAgcHJveHlIb3N0ICs9IFwiODBcIjtcbiAgfVxuICByZXR1cm4gcHJveHlIb3N0O1xufVxuZnVuY3Rpb24gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhoZWFkZXJzLCB3aGl0ZUxpc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbHRlcigoaGVhZGVyKSA9PiB3aGl0ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgIT09IC0xKS5yZWR1Y2UoKHNldCwgaGVhZGVyKSA9PiB7XG4gICAgc2V0W2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgcmV0dXJuIHNldDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsT3B0aW9ucyhvcHRpb25zLCBwcm94eSwgcHJveHlIZWFkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgcHJveHk6IHtcbiAgICAgIGhvc3Q6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgcG9ydDogK3Byb3h5LnBvcnQsXG4gICAgICBwcm94eUF1dGg6IHByb3h5LmF1dGgsXG4gICAgICBoZWFkZXJzOiBwcm94eUhlYWRlcnNcbiAgICB9LFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICBjYTogb3B0aW9ucy5jYSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQsXG4gICAga2V5OiBvcHRpb25zLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBzZWN1cmVPcHRpb25zOiBvcHRpb25zLnNlY3VyZU9wdGlvbnMsXG4gICAgc2VjdXJlUHJvdG9jb2w6IG9wdGlvbnMuc2VjdXJlUHJvdG9jb2xcbiAgfTtcbn1cblxuY29uc3QgYWRhcHRlciA9IFwibm9kZVwiO1xuY29uc3QgcmVkdWNlUmVzcG9uc2UgPSAocmVzLCByZXFVcmwsIG1ldGhvZCwgYm9keSkgPT4gKHtcbiAgYm9keSxcbiAgdXJsOiByZXFVcmwsXG4gIG1ldGhvZCxcbiAgaGVhZGVyczogcmVzLmhlYWRlcnMsXG4gIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICBzdGF0dXNNZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZVxufSk7XG5jb25zdCBodHRwUmVxdWVzdGVyID0gKGNvbnRleHQsIGNiKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgY29uc3QgdXJpID0gT2JqZWN0LmFzc2lnbih7fSwgdXJsX19kZWZhdWx0LmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwpKTtcbiAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuZmV0Y2gpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlcU9wdHMyID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJmaW5hbGl6ZU9wdGlvbnNcIiwge1xuICAgICAgLi4udXJpLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5mZXRjaC5oZWFkZXJzID8gbG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmZldGNoLmhlYWRlcnMpIDoge30sXG4gICAgICAgIC4uLmxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgfSxcbiAgICAgIG1heFJlZGlyZWN0czogb3B0aW9ucy5tYXhSZWRpcmVjdHNcbiAgICB9KTtcbiAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICBjcmVkZW50aWFsczogb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwib21pdFwiLFxuICAgICAgLi4udHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmZldGNoIDoge30sXG4gICAgICBtZXRob2Q6IHJlcU9wdHMyLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHJlcU9wdHMyLmhlYWRlcnMsXG4gICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgfTtcbiAgICBjb25zdCBpbmplY3RlZFJlc3BvbnNlMiA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICAgIGFkYXB0ZXIsXG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgaWYgKGluamVjdGVkUmVzcG9uc2UyKSB7XG4gICAgICBjb25zdCBjYlRpbWVyID0gc2V0VGltZW91dChjYiwgMCwgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZTIpO1xuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4gY2xlYXJUaW1lb3V0KGNiVGltZXIpO1xuICAgICAgcmV0dXJuIHsgYWJvcnQ6IGNhbmNlbCB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0MiA9IGZldGNoKG9wdGlvbnMudXJsLCBmZXRjaE9wdHMpO1xuICAgIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwib25SZXF1ZXN0XCIsIHsgb3B0aW9ucywgYWRhcHRlciwgcmVxdWVzdDogcmVxdWVzdDIsIGNvbnRleHQgfSk7XG4gICAgcmVxdWVzdDIudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5yYXdCb2R5ID8gcmVzLmJvZHkgOiBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgcmVzLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgY2IobnVsbCwge1xuICAgICAgICBib2R5LFxuICAgICAgICB1cmw6IHJlcy51cmwsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMsXG4gICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlcy5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT0gXCJBYm9ydEVycm9yXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNiKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgYWJvcnQ6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSB9O1xuICB9XG4gIGNvbnN0IGJvZHlUeXBlID0gaXNTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpID8gXCJzdHJlYW1cIiA6IHR5cGVvZiBvcHRpb25zLmJvZHk7XG4gIGlmIChib2R5VHlwZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJlYW1cIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJpbmdcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuYm9keSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbSwgZ290IFwiLmNvbmNhdChib2R5VHlwZSkpO1xuICB9XG4gIGNvbnN0IGxlbmd0aEhlYWRlciA9IHt9O1xuICBpZiAob3B0aW9ucy5ib2R5U2l6ZSkge1xuICAgIGxlbmd0aEhlYWRlcltcImNvbnRlbnQtbGVuZ3RoXCJdID0gb3B0aW9ucy5ib2R5U2l6ZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmJvZHkgJiYgYm9keVR5cGUgIT09IFwic3RyZWFtXCIpIHtcbiAgICBsZW5ndGhIZWFkZXJbXCJjb250ZW50LWxlbmd0aFwiXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgY29uc3QgY2FsbGJhY2sgPSAoZXJyLCByZXMpID0+ICFhYm9ydGVkICYmIGNiKGVyciwgcmVzKTtcbiAgY29udGV4dC5jaGFubmVscy5hYm9ydC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IHJlcU9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB1cmksIHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKSwgbGVuZ3RoSGVhZGVyKSxcbiAgICBtYXhSZWRpcmVjdHM6IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gIH0pO1xuICBjb25zdCBwcm94eSA9IGdldFByb3h5T3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgdHVubmVsID0gcHJveHkgJiYgc2hvdWxkRW5hYmxlKG9wdGlvbnMpO1xuICBjb25zdCBpbmplY3RlZFJlc3BvbnNlID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJpbnRlcmNlcHRSZXF1ZXN0XCIsIHZvaWQgMCwge1xuICAgIGFkYXB0ZXIsXG4gICAgY29udGV4dFxuICB9KTtcbiAgaWYgKGluamVjdGVkUmVzcG9uc2UpIHtcbiAgICBjb25zdCBjYlRpbWVyID0gc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCBudWxsLCBpbmplY3RlZFJlc3BvbnNlKTtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IGNsZWFySW1tZWRpYXRlKGNiVGltZXIpO1xuICAgIHJldHVybiB7IGFib3J0IH07XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzICE9PSAwKSB7XG4gICAgcmVxT3B0cy5tYXhSZWRpcmVjdHMgPSBvcHRpb25zLm1heFJlZGlyZWN0cyB8fCA1O1xuICB9XG4gIGlmIChwcm94eSAmJiB0dW5uZWwpIHtcbiAgICByZXFPcHRzID0gYXBwbHlBZ2VudChyZXFPcHRzLCBwcm94eSk7XG4gIH0gZWxzZSBpZiAocHJveHkgJiYgIXR1bm5lbCkge1xuICAgIHJlcU9wdHMgPSByZXdyaXRlVXJpRm9yUHJveHkocmVxT3B0cywgdXJpLCBwcm94eSk7XG4gIH1cbiAgaWYgKCF0dW5uZWwgJiYgcHJveHkgJiYgcHJveHkuYXV0aCAmJiAhcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSkge1xuICAgIGNvbnN0IFt1c2VybmFtZSwgcGFzc3dvcmRdID0gcHJveHkuYXV0aC51c2VybmFtZSA/IFtwcm94eS5hdXRoLnVzZXJuYW1lLCBwcm94eS5hdXRoLnBhc3N3b3JkXSA6IHByb3h5LmF1dGguc3BsaXQoXCI6XCIpLm1hcCgoaXRlbSkgPT4gcXNfX2RlZmF1bHQuZGVmYXVsdC51bmVzY2FwZShpdGVtKSk7XG4gICAgY29uc3QgYXV0aCA9IEJ1ZmZlci5mcm9tKFwiXCIuY29uY2F0KHVzZXJuYW1lLCBcIjpcIikuY29uY2F0KHBhc3N3b3JkKSwgXCJ1dGY4XCIpO1xuICAgIGNvbnN0IGF1dGhCYXNlNjQgPSBhdXRoLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIHJlcU9wdHMuaGVhZGVyc1tcInByb3h5LWF1dGhvcml6YXRpb25cIl0gPSBcIkJhc2ljIFwiLmNvbmNhdChhdXRoQmFzZTY0KTtcbiAgfVxuICBjb25zdCB0cmFuc3BvcnQgPSBnZXRSZXF1ZXN0VHJhbnNwb3J0KHJlcU9wdHMsIHByb3h5LCB0dW5uZWwpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZGVidWcgPT09IFwiZnVuY3Rpb25cIiAmJiBwcm94eSkge1xuICAgIG9wdGlvbnMuZGVidWcoXG4gICAgICBcIlByb3h5aW5nIHVzaW5nICVzXCIsXG4gICAgICByZXFPcHRzLmFnZW50ID8gXCJ0dW5uZWwgYWdlbnRcIiA6IFwiXCIuY29uY2F0KHJlcU9wdHMuaG9zdCwgXCI6XCIpLmNvbmNhdChyZXFPcHRzLnBvcnQpXG4gICAgKTtcbiAgfVxuICBjb25zdCB0cnlDb21wcmVzc2VkID0gcmVxT3B0cy5tZXRob2QgIT09IFwiSEVBRFwiO1xuICBpZiAodHJ5Q29tcHJlc3NlZCAmJiAhcmVxT3B0cy5oZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdICYmIG9wdGlvbnMuY29tcHJlc3MgIT09IGZhbHNlKSB7XG4gICAgcmVxT3B0cy5oZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJiciwgZ3ppcCwgZGVmbGF0ZVwiO1xuICB9XG4gIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFxuICAgIFwiZmluYWxpemVPcHRpb25zXCIsXG4gICAgcmVxT3B0c1xuICApO1xuICBjb25zdCByZXF1ZXN0ID0gdHJhbnNwb3J0LnJlcXVlc3QoZmluYWxPcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCByZXMgPSB0cnlDb21wcmVzc2VkID8gZGVjb21wcmVzc1Jlc3BvbnNlX19kZWZhdWx0LmRlZmF1bHQocmVzcG9uc2UpIDogcmVzcG9uc2U7XG4gICAgY29uc3QgcmVzU3RyZWFtID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvbkhlYWRlcnNcIiwgcmVzLCB7XG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgYWRhcHRlcixcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICBjb25zdCByZXFVcmwgPSBcInJlc3BvbnNlVXJsXCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZS5yZXNwb25zZVVybCA6IG9wdGlvbnMudXJsO1xuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UocmVzLCByZXFVcmwsIHJlcU9wdHMubWV0aG9kLCByZXNTdHJlYW0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uY2F0KHJlc1N0cmVhbSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLnJhd0JvZHkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVkdWNlZCA9IHJlZHVjZVJlc3BvbnNlKHJlcywgcmVxVXJsLCByZXFPcHRzLm1ldGhvZCwgYm9keSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVkdWNlZCk7XG4gICAgfSk7XG4gIH0pO1xuICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgdGltZWRPdXQocmVxdWVzdCwgb3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICByZXF1ZXN0Lm9uY2UoXCJlcnJvclwiLCBjYWxsYmFjayk7XG4gIGNvbnN0IHsgYm9keVN0cmVhbSwgcHJvZ3Jlc3MgfSA9IGdldFByb2dyZXNzU3RyZWFtKG9wdGlvbnMpO1xuICBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uUmVxdWVzdFwiLCB7IG9wdGlvbnMsIGFkYXB0ZXIsIHJlcXVlc3QsIGNvbnRleHQsIHByb2dyZXNzIH0pO1xuICBpZiAoYm9keVN0cmVhbSkge1xuICAgIGJvZHlTdHJlYW0ucGlwZShyZXF1ZXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LmVuZChvcHRpb25zLmJvZHkpO1xuICB9XG4gIHJldHVybiB7IGFib3J0OiAoKSA9PiByZXF1ZXN0LmFib3J0KCkgfTtcbn07XG5mdW5jdGlvbiBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5ib2R5KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IGJvZHlJc1N0cmVhbSA9IGlzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQob3B0aW9ucy5ib2R5KTtcbiAgY29uc3QgbGVuZ3RoID0gb3B0aW9ucy5ib2R5U2l6ZSB8fCAoYm9keUlzU3RyZWFtID8gbnVsbCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSkpO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBib2R5SXNTdHJlYW0gPyB7IGJvZHlTdHJlYW06IG9wdGlvbnMuYm9keSB9IDoge307XG4gIH1cbiAgY29uc3QgcHJvZ3Jlc3MgPSBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KHsgdGltZTogMTYsIGxlbmd0aCB9KTtcbiAgY29uc3QgYm9keVN0cmVhbSA9IGJvZHlJc1N0cmVhbSA/IG9wdGlvbnMuYm9keSA6IHRvU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQob3B0aW9ucy5ib2R5KTtcbiAgcmV0dXJuIHsgYm9keVN0cmVhbTogYm9keVN0cmVhbS5waXBlKHByb2dyZXNzKSwgcHJvZ3Jlc3MgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RUcmFuc3BvcnQocmVxT3B0cywgcHJveHksIHR1bm5lbCkge1xuICBjb25zdCBpc0h0dHBzUmVxdWVzdCA9IHJlcU9wdHMucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gIGNvbnN0IHRyYW5zcG9ydHMgPSByZXFPcHRzLm1heFJlZGlyZWN0cyA9PT0gMCA/IHsgaHR0cDogaHR0cF9fZGVmYXVsdC5kZWZhdWx0LCBodHRwczogaHR0cHNfX2RlZmF1bHQuZGVmYXVsdCB9IDogeyBodHRwOiBmb2xsb3dfX2RlZmF1bHQuZGVmYXVsdC5odHRwLCBodHRwczogZm9sbG93X19kZWZhdWx0LmRlZmF1bHQuaHR0cHMgfTtcbiAgaWYgKCFwcm94eSB8fCB0dW5uZWwpIHtcbiAgICByZXR1cm4gaXNIdHRwc1JlcXVlc3QgPyB0cmFuc3BvcnRzLmh0dHBzIDogdHJhbnNwb3J0cy5odHRwO1xuICB9XG4gIGxldCBpc0h0dHBzUHJveHkgPSBwcm94eS5wb3J0ID09PSA0NDM7XG4gIGlmIChwcm94eS5wcm90b2NvbCkge1xuICAgIGlzSHR0cHNQcm94eSA9IC9eaHR0cHM6Py8udGVzdChwcm94eS5wcm90b2NvbCk7XG4gIH1cbiAgcmV0dXJuIGlzSHR0cHNQcm94eSA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG59XG5cbmNvbnN0IGdldEl0ID0gKGluaXRNaWRkbGV3YXJlID0gW10sIGh0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3RlcikgPT4gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCk7XG5jb25zdCBlbnZpcm9ubWVudCA9IFwibm9kZVwiO1xuXG5leHBvcnRzLmFkYXB0ZXIgPSBhZGFwdGVyO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuZXhwb3J0cy5nZXRJdCA9IGdldEl0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.cjs":
/*!*************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar debugIt = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-n1t8zknB.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs\");\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar allowed = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\n\nfunction _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }\n\nvar debugIt__default = /*#__PURE__*/_interopDefaultCompat(debugIt);\nvar progressStream__default = /*#__PURE__*/_interopDefaultCompat(progressStream);\nvar allowed__default = /*#__PURE__*/_interopDefaultCompat(allowed);\n\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n  const httpAgent = new http.Agent(opts);\n  const httpsAgent = new https.Agent(opts);\n  const agents = { http: httpAgent, https: httpsAgent };\n  return {\n    finalizeOptions: (options) => {\n      if (options.agent) {\n        return options;\n      }\n      if (options.maxRedirects > 0) {\n        return { ...options, agents };\n      }\n      const isHttps = isHttpsProto.test(options.href || options.protocol);\n      return { ...options, agent: isHttps ? httpsAgent : httpAgent };\n    }\n  };\n}\n\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n  const baseUri = baseUrl.replace(trailingSlash, \"\");\n  return {\n    processOptions: (options) => {\n      if (/^https?:\\/\\//i.test(options.url)) {\n        return options;\n      }\n      const url = [baseUri, options.url.replace(leadingSlash, \"\")].join(\"/\");\n      return Object.assign({}, options, { url });\n    }\n  };\n}\n\nconst SENSITIVE_HEADERS = [\"cookie\", \"authorization\"];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted) => {\n  const target = {};\n  for (const key in source) {\n    if (hasOwn.call(source, key)) {\n      target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n    }\n  }\n  return target;\n};\nfunction debug(opts = {}) {\n  const verbose = opts.verbose;\n  const namespace = opts.namespace || \"get-it\";\n  const defaultLogger = debugIt__default.default(namespace);\n  const log = opts.log || defaultLogger;\n  const shortCircuit = log === defaultLogger && !debugIt__default.default.enabled(namespace);\n  let requestId = 0;\n  return {\n    processOptions: (options) => {\n      options.debug = log;\n      options.requestId = options.requestId || ++requestId;\n      return options;\n    },\n    onRequest: (event) => {\n      if (shortCircuit || !event) {\n        return event;\n      }\n      const options = event.options;\n      log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n      if (verbose && options.body && typeof options.body === \"string\") {\n        log(\"[%s] Request body: %s\", options.requestId, options.body);\n      }\n      if (verbose && options.headers) {\n        const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n        log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n      }\n      return event;\n    },\n    onResponse: (res, context) => {\n      if (shortCircuit || !res) {\n        return res;\n      }\n      const reqId = context.options.requestId;\n      log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n      if (verbose && res.body) {\n        log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n      }\n      return res;\n    },\n    onError: (err, context) => {\n      const reqId = context.options.requestId;\n      if (!err) {\n        log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n        return err;\n      }\n      log(\"[%s] ERROR: %s\", reqId, err.message);\n      return err;\n    }\n  };\n}\nfunction stringifyBody(res) {\n  const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n  const isJson = contentType.indexOf(\"application/json\") !== -1;\n  return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n  try {\n    const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n    return JSON.stringify(parsed, null, 2);\n  } catch (err) {\n    return body;\n  }\n}\n\nfunction headers(_headers, opts = {}) {\n  return {\n    processOptions: (options) => {\n      const existing = options.headers || {};\n      options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n      return options;\n    }\n  };\n}\n\nclass HttpError extends Error {\n  constructor(res, ctx) {\n    super();\n    const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"\\u2026\") : res.url;\n    let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n    msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n    this.message = msg.trim();\n    this.response = res;\n    this.request = ctx.options;\n  }\n}\nfunction httpErrors() {\n  return {\n    onResponse: (res, ctx) => {\n      const isHttpError = res.statusCode >= 400;\n      if (!isHttpError) {\n        return res;\n      }\n      throw new HttpError(res, ctx);\n    }\n  };\n}\n\nfunction injectResponse(opts = {}) {\n  if (typeof opts.inject !== \"function\") {\n    throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n  }\n  const inject = function inject2(prevValue, event) {\n    const response = opts.inject(event, prevValue);\n    if (!response) {\n      return prevValue;\n    }\n    const options = event.context.options;\n    return {\n      body: \"\",\n      url: options.url,\n      method: options.method,\n      headers: {},\n      statusCode: 200,\n      statusMessage: \"OK\",\n      ...response\n    };\n  };\n  return { interceptRequest: inject };\n}\n\nconst isBuffer = typeof Buffer === \"undefined\" ? () => false : (obj) => Buffer.isBuffer(obj);\n\nconst serializeTypes = [\"boolean\", \"string\", \"number\"];\nfunction jsonRequest() {\n  return {\n    processOptions: (options) => {\n      const body = options.body;\n      if (!body) {\n        return options;\n      }\n      const isStream = typeof body.pipe === \"function\";\n      const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject.isPlainObject(body));\n      if (!shouldSerialize) {\n        return options;\n      }\n      return Object.assign({}, options, {\n        body: JSON.stringify(options.body),\n        headers: Object.assign({}, options.headers, {\n          \"Content-Type\": \"application/json\"\n        })\n      });\n    }\n  };\n}\n\nfunction jsonResponse(opts) {\n  return {\n    onResponse: (response) => {\n      const contentType = response.headers[\"content-type\"] || \"\";\n      const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n      if (!response.body || !contentType || !shouldDecode) {\n        return response;\n      }\n      return Object.assign({}, response, { body: tryParse(response.body) });\n    },\n    processOptions: (options) => Object.assign({}, options, {\n      headers: Object.assign({ Accept: \"application/json\" }, options.headers)\n    })\n  };\n  function tryParse(body) {\n    try {\n      return JSON.parse(body);\n    } catch (err) {\n      err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n      throw err;\n    }\n  }\n}\n\nfunction isBrowserOptions(options) {\n  return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\n\nfunction mtls(config = {}) {\n  if (!config.ca) {\n    throw new Error('Required mtls option \"ca\" is missing');\n  }\n  if (!config.cert) {\n    throw new Error('Required mtls option \"cert\" is missing');\n  }\n  if (!config.key) {\n    throw new Error('Required mtls option \"key\" is missing');\n  }\n  return {\n    finalizeOptions: (options) => {\n      if (isBrowserOptions(options)) {\n        return options;\n      }\n      const mtlsOpts = {\n        cert: config.cert,\n        key: config.key,\n        ca: config.ca\n      };\n      return Object.assign({}, options, mtlsOpts);\n    }\n  };\n}\n\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n  actualGlobal = globalThis;\n} else if (typeof window !== \"undefined\") {\n  actualGlobal = window;\n} else if (typeof global !== \"undefined\") {\n  actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n  actualGlobal = self;\n}\nvar global$1 = actualGlobal;\n\nfunction observable(opts = {}) {\n  const Observable = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable\n  );\n  if (!Observable) {\n    throw new Error(\n      \"`Observable` is not available in global scope, and no implementation was passed\"\n    );\n  }\n  return {\n    onReturn: (channels, context) => new Observable((observer) => {\n      channels.error.subscribe((err) => observer.error(err));\n      channels.progress.subscribe(\n        (event) => observer.next(Object.assign({ type: \"progress\" }, event))\n      );\n      channels.response.subscribe((response) => {\n        observer.next(Object.assign({ type: \"response\" }, response));\n        observer.complete();\n      });\n      channels.request.publish(context);\n      return () => channels.abort.publish();\n    })\n  };\n}\n\nfunction normalizer(stage) {\n  return (prog) => ({\n    stage,\n    percent: prog.percentage,\n    total: prog.length,\n    loaded: prog.transferred,\n    lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n  });\n}\nfunction progress() {\n  return {\n    onHeaders: (response, evt) => {\n      const _progress = progressStream__default.default({ time: 16 });\n      const normalize = normalizer(\"download\");\n      const contentLength = response.headers[\"content-length\"];\n      const length = contentLength ? Number(contentLength) : 0;\n      if (!isNaN(length) && length > 0) {\n        _progress.setLength(length);\n      }\n      _progress.on(\"progress\", (prog) => evt.context.channels.progress.publish(normalize(prog)));\n      return response.pipe(_progress);\n    },\n    onRequest: (evt) => {\n      if (!evt.progress) {\n        return;\n      }\n      const normalize = normalizer(\"upload\");\n      evt.progress.on(\n        \"progress\",\n        (prog) => evt.context.channels.progress.publish(normalize(prog))\n      );\n    }\n  };\n}\n\nconst promise = (options = {}) => {\n  const PromiseImplementation = options.implementation || Promise;\n  if (!PromiseImplementation) {\n    throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n  }\n  return {\n    onReturn: (channels, context) => new PromiseImplementation((resolve, reject) => {\n      const cancel = context.options.cancelToken;\n      if (cancel) {\n        cancel.promise.then((reason) => {\n          channels.abort.publish(reason);\n          reject(reason);\n        });\n      }\n      channels.error.subscribe(reject);\n      channels.response.subscribe((response) => {\n        resolve(options.onlyBody ? response.body : response);\n      });\n      setTimeout(() => {\n        try {\n          channels.request.publish(context);\n        } catch (err) {\n          reject(err);\n        }\n      }, 0);\n    })\n  };\n};\nclass Cancel {\n  constructor(message) {\n    this.__CANCEL__ = true;\n    this.message = message;\n  }\n  toString() {\n    return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n  }\n}\nconst _CancelToken = class _CancelToken {\n  constructor(executor) {\n    if (typeof executor !== \"function\") {\n      throw new TypeError(\"executor must be a function.\");\n    }\n    let resolvePromise = null;\n    this.promise = new Promise((resolve) => {\n      resolvePromise = resolve;\n    });\n    executor((message) => {\n      if (this.reason) {\n        return;\n      }\n      this.reason = new Cancel(message);\n      resolvePromise(this.reason);\n    });\n  }\n};\n_CancelToken.source = () => {\n  let cancel;\n  const token = new _CancelToken((can) => {\n    cancel = can;\n  });\n  return {\n    token,\n    cancel\n  };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value) => !!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\n\nfunction proxy(_proxy) {\n  if (_proxy !== false && (!_proxy || !_proxy.host)) {\n    throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n  }\n  return {\n    processOptions: (options) => Object.assign({ proxy: _proxy }, options)\n  };\n}\n\nvar defaultShouldRetry = (err, num, options) => {\n  if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n    return false;\n  }\n  if (err.response && err.response.statusCode) {\n    return false;\n  }\n  return allowed__default.default(err);\n};\n\nconst isStream = (stream) => stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts) => {\n  const maxRetries = opts.maxRetries || 5;\n  const retryDelay = opts.retryDelay || getRetryDelay;\n  const allowRetry = opts.shouldRetry;\n  return {\n    onError: (err, context) => {\n      const options = context.options;\n      const max = options.maxRetries || maxRetries;\n      const shouldRetry = options.shouldRetry || allowRetry;\n      const attemptNumber = options.attemptNumber || 0;\n      if (isStream(options.body)) {\n        return err;\n      }\n      if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n        return err;\n      }\n      const newContext = Object.assign({}, context, {\n        options: Object.assign({}, options, { attemptNumber: attemptNumber + 1 })\n      });\n      setTimeout(() => context.channels.request.publish(newContext), retryDelay(attemptNumber));\n      return null;\n    }\n  };\n};\nfunction getRetryDelay(attemptNum) {\n  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\n\nconst retry = (opts = {}) => sharedRetry({ shouldRetry: defaultShouldRetry, ...opts });\nretry.shouldRetry = defaultShouldRetry;\n\nfunction encode(data) {\n  const query = new URLSearchParams();\n  const nest = (name, _value) => {\n    const value = _value instanceof Set ? Array.from(_value) : _value;\n    if (Array.isArray(value)) {\n      if (value.length) {\n        for (const index in value) {\n          nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n        }\n      } else {\n        query.append(\"\".concat(name, \"[]\"), \"\");\n      }\n    } else if (typeof value === \"object\" && value !== null) {\n      for (const [key, obj] of Object.entries(value)) {\n        nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n      }\n    } else {\n      query.append(name, value);\n    }\n  };\n  for (const [key, value] of Object.entries(data)) {\n    nest(key, value);\n  }\n  return query.toString();\n}\nfunction urlEncoded() {\n  return {\n    processOptions: (options) => {\n      const body = options.body;\n      if (!body) {\n        return options;\n      }\n      const isStream = typeof body.pipe === \"function\";\n      const shouldSerialize = !isStream && !isBuffer(body) && isPlainObject.isPlainObject(body);\n      if (!shouldSerialize) {\n        return options;\n      }\n      return {\n        ...options,\n        body: encode(options.body),\n        headers: {\n          ...options.headers,\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n      };\n    }\n  };\n}\n\nfunction buildKeepAlive(agent) {\n  return function keepAlive(config = {}) {\n    const ms = config.ms || 1e3;\n    const maxFree = config.maxFree || 256;\n    const agentOptions = {\n      keepAlive: true,\n      keepAliveMsecs: ms,\n      maxFreeSockets: maxFree\n    };\n    return agent(agentOptions);\n  };\n}\n\nconst keepAlive = buildKeepAlive(agent);\n\nexports.processOptions = defaultOptionsValidator.processOptions;\nexports.validateOptions = defaultOptionsValidator.validateOptions;\nexports.Cancel = Cancel;\nexports.CancelToken = CancelToken;\nexports.agent = agent;\nexports.base = base;\nexports.debug = debug;\nexports.headers = headers;\nexports.httpErrors = httpErrors;\nexports.injectResponse = injectResponse;\nexports.jsonRequest = jsonRequest;\nexports.jsonResponse = jsonResponse;\nexports.keepAlive = keepAlive;\nexports.mtls = mtls;\nexports.observable = observable;\nexports.progress = progress;\nexports.promise = promise;\nexports.proxy = proxy;\nexports.retry = retry;\nexports.urlEncoded = urlEncoded;\n//# sourceMappingURL=middleware.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3Qiw4QkFBOEIsbUJBQU8sQ0FBQyxxSUFBZ0Q7QUFDdEYsb0JBQW9CLG1CQUFPLENBQUMscUZBQWlCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLHNFQUFpQjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsd0VBQWtCOztBQUV4QyxxQ0FBcUMsNERBQTREOztBQUVqRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsaUNBQWlDLGFBQWEsa0NBQWtDO0FBQ2hGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUIsMENBQTBDO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsYUFBYTtBQUNiLFlBQVk7QUFDWixhQUFhO0FBQ2IsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGFBQWE7QUFDYixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhbHRvci8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9taWRkbGV3YXJlLmNqcz8wNzczIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIGRlYnVnSXQgPSByZXF1aXJlKCdkZWJ1ZycpO1xudmFyIGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yID0gcmVxdWlyZSgnLi9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLW4xdDh6a25CLmNqcycpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcbnZhciBwcm9ncmVzc1N0cmVhbSA9IHJlcXVpcmUoJ3Byb2dyZXNzLXN0cmVhbScpO1xudmFyIGFsbG93ZWQgPSByZXF1aXJlKCdpcy1yZXRyeS1hbGxvd2VkJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdENvbXBhdCAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIGRlYnVnSXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGRlYnVnSXQpO1xudmFyIHByb2dyZXNzU3RyZWFtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChwcm9ncmVzc1N0cmVhbSk7XG52YXIgYWxsb3dlZF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoYWxsb3dlZCk7XG5cbmNvbnN0IGlzSHR0cHNQcm90byA9IC9eaHR0cHM6L2k7XG5mdW5jdGlvbiBhZ2VudChvcHRzKSB7XG4gIGNvbnN0IGh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KG9wdHMpO1xuICBjb25zdCBodHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KG9wdHMpO1xuICBjb25zdCBhZ2VudHMgPSB7IGh0dHA6IGh0dHBBZ2VudCwgaHR0cHM6IGh0dHBzQWdlbnQgfTtcbiAgcmV0dXJuIHtcbiAgICBmaW5hbGl6ZU9wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5hZ2VudCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgYWdlbnRzIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpc0h0dHBzID0gaXNIdHRwc1Byb3RvLnRlc3Qob3B0aW9ucy5ocmVmIHx8IG9wdGlvbnMucHJvdG9jb2wpO1xuICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgYWdlbnQ6IGlzSHR0cHMgPyBodHRwc0FnZW50IDogaHR0cEFnZW50IH07XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBsZWFkaW5nU2xhc2ggPSAvXlxcLy87XG5jb25zdCB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xuZnVuY3Rpb24gYmFzZShiYXNlVXJsKSB7XG4gIGNvbnN0IGJhc2VVcmkgPSBiYXNlVXJsLnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgXCJcIik7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCB1cmwgPSBbYmFzZVVyaSwgb3B0aW9ucy51cmwucmVwbGFjZShsZWFkaW5nU2xhc2gsIFwiXCIpXS5qb2luKFwiL1wiKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHVybCB9KTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IFNFTlNJVElWRV9IRUFERVJTID0gW1wiY29va2llXCIsIFwiYXV0aG9yaXphdGlvblwiXTtcbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCByZWRhY3RLZXlzID0gKHNvdXJjZSwgcmVkYWN0ZWQpID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd24uY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gcmVkYWN0ZWQuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPiAtMSA/IFwiPHJlZGFjdGVkPlwiIDogc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuZnVuY3Rpb24gZGVidWcob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHZlcmJvc2UgPSBvcHRzLnZlcmJvc2U7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IG9wdHMubmFtZXNwYWNlIHx8IFwiZ2V0LWl0XCI7XG4gIGNvbnN0IGRlZmF1bHRMb2dnZXIgPSBkZWJ1Z0l0X19kZWZhdWx0LmRlZmF1bHQobmFtZXNwYWNlKTtcbiAgY29uc3QgbG9nID0gb3B0cy5sb2cgfHwgZGVmYXVsdExvZ2dlcjtcbiAgY29uc3Qgc2hvcnRDaXJjdWl0ID0gbG9nID09PSBkZWZhdWx0TG9nZ2VyICYmICFkZWJ1Z0l0X19kZWZhdWx0LmRlZmF1bHQuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBsZXQgcmVxdWVzdElkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMuZGVidWcgPSBsb2c7XG4gICAgICBvcHRpb25zLnJlcXVlc3RJZCA9IG9wdGlvbnMucmVxdWVzdElkIHx8ICsrcmVxdWVzdElkO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcbiAgICBvblJlcXVlc3Q6IChldmVudCkgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50Lm9wdGlvbnM7XG4gICAgICBsb2coXCJbJXNdIEhUVFAgJXMgJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCk7XG4gICAgICBpZiAodmVyYm9zZSAmJiBvcHRpb25zLmJvZHkgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2coXCJbJXNdIFJlcXVlc3QgYm9keTogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMuYm9keSk7XG4gICAgICB9XG4gICAgICBpZiAodmVyYm9zZSAmJiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG9wdHMucmVkYWN0U2Vuc2l0aXZlSGVhZGVycyA9PT0gZmFsc2UgPyBvcHRpb25zLmhlYWRlcnMgOiByZWRhY3RLZXlzKG9wdGlvbnMuaGVhZGVycywgU0VOU0lUSVZFX0hFQURFUlMpO1xuICAgICAgICBsb2coXCJbJXNdIFJlcXVlc3QgaGVhZGVyczogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMsIG51bGwsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2U6IChyZXMsIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIXJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgbG9nKFwiWyVzXSBSZXNwb25zZSBjb2RlOiAlcyAlc1wiLCByZXFJZCwgcmVzLnN0YXR1c0NvZGUsIHJlcy5zdGF0dXNNZXNzYWdlKTtcbiAgICAgIGlmICh2ZXJib3NlICYmIHJlcy5ib2R5KSB7XG4gICAgICAgIGxvZyhcIlslc10gUmVzcG9uc2UgYm9keTogJXNcIiwgcmVxSWQsIHN0cmluZ2lmeUJvZHkocmVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBFcnJvciBlbmNvdW50ZXJlZCwgYnV0IGhhbmRsZWQgYnkgYW4gZWFybGllciBtaWRkbGV3YXJlXCIsIHJlcUlkKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGxvZyhcIlslc10gRVJST1I6ICVzXCIsIHJlcUlkLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkocmVzKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gKHJlcy5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGlzSnNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMTtcbiAgcmV0dXJuIGlzSnNvbiA/IHRyeUZvcm1hdChyZXMuYm9keSkgOiByZXMuYm9keTtcbn1cbmZ1bmN0aW9uIHRyeUZvcm1hdChib2R5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gdHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGVhZGVycyhfaGVhZGVycywgb3B0cyA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdHMub3ZlcnJpZGUgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgX2hlYWRlcnMpIDogT2JqZWN0LmFzc2lnbih7fSwgX2hlYWRlcnMsIGV4aXN0aW5nKTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfTtcbn1cblxuY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMsIGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJ1bmNhdGVkVXJsID0gcmVzLnVybC5sZW5ndGggPiA0MDAgPyBcIlwiLmNvbmNhdChyZXMudXJsLnNsaWNlKDAsIDM5OSksIFwiXFx1MjAyNlwiKSA6IHJlcy51cmw7XG4gICAgbGV0IG1zZyA9IFwiXCIuY29uY2F0KHJlcy5tZXRob2QsIFwiLXJlcXVlc3QgdG8gXCIpLmNvbmNhdCh0cnVuY2F0ZWRVcmwsIFwiIHJlc3VsdGVkIGluIFwiKTtcbiAgICBtc2cgKz0gXCJIVFRQIFwiLmNvbmNhdChyZXMuc3RhdHVzQ29kZSwgXCIgXCIpLmNvbmNhdChyZXMuc3RhdHVzTWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnLnRyaW0oKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzO1xuICAgIHRoaXMucmVxdWVzdCA9IGN0eC5vcHRpb25zO1xuICB9XG59XG5mdW5jdGlvbiBodHRwRXJyb3JzKCkge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgaXNIdHRwRXJyb3IgPSByZXMuc3RhdHVzQ29kZSA+PSA0MDA7XG4gICAgICBpZiAoIWlzSHR0cEVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlcywgY3R4KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdFJlc3BvbnNlKG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdHMuaW5qZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaW5qZWN0UmVzcG9uc2VgIG1pZGRsZXdhcmUgcmVxdWlyZXMgYSBgaW5qZWN0YCBmdW5jdGlvblwiKTtcbiAgfVxuICBjb25zdCBpbmplY3QgPSBmdW5jdGlvbiBpbmplY3QyKHByZXZWYWx1ZSwgZXZlbnQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IG9wdHMuaW5qZWN0KGV2ZW50LCBwcmV2VmFsdWUpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IFwiXCIsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgc3RhdHVzTWVzc2FnZTogXCJPS1wiLFxuICAgICAgLi4ucmVzcG9uc2VcbiAgICB9O1xuICB9O1xuICByZXR1cm4geyBpbnRlcmNlcHRSZXF1ZXN0OiBpbmplY3QgfTtcbn1cblxuY29uc3QgaXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSBcInVuZGVmaW5lZFwiID8gKCkgPT4gZmFsc2UgOiAob2JqKSA9PiBCdWZmZXIuaXNCdWZmZXIob2JqKTtcblxuY29uc3Qgc2VyaWFsaXplVHlwZXMgPSBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCJdO1xuZnVuY3Rpb24ganNvblJlcXVlc3QoKSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBjb25zdCBzaG91bGRTZXJpYWxpemUgPSAhaXNTdHJlYW0gJiYgIWlzQnVmZmVyKGJvZHkpICYmIChzZXJpYWxpemVUeXBlcy5pbmRleE9mKHR5cGVvZiBib2R5KSAhPT0gLTEgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYm9keSkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBqc29uUmVzcG9uc2Uob3B0cykge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCI7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGUgPSBvcHRzICYmIG9wdHMuZm9yY2UgfHwgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xO1xuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5IHx8ICFjb250ZW50VHlwZSB8fCAhc2hvdWxkRGVjb2RlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSwgeyBib2R5OiB0cnlQYXJzZShyZXNwb25zZS5ib2R5KSB9KTtcbiAgICB9LFxuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pXG4gIH07XG4gIGZ1bmN0aW9uIHRyeVBhcnNlKGJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IFwiRmFpbGVkIHRvIHBhcnNlZCByZXNwb25zZSBib2R5IGFzIEpTT046IFwiLmNvbmNhdChlcnIubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCAmJiAhKFwicHJvdG9jb2xcIiBpbiBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbXRscyhjb25maWcgPSB7fSkge1xuICBpZiAoIWNvbmZpZy5jYSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJjYVwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWNvbmZpZy5jZXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNlcnRcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFjb25maWcua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImtleVwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbmFsaXplT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgbXRsc09wdHMgPSB7XG4gICAgICAgIGNlcnQ6IGNvbmZpZy5jZXJ0LFxuICAgICAgICBrZXk6IGNvbmZpZy5rZXksXG4gICAgICAgIGNhOiBjb25maWcuY2FcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgbXRsc09wdHMpO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGFjdHVhbEdsb2JhbCA9IHt9O1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IGdsb2JhbFRoaXM7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gc2VsZjtcbn1cbnZhciBnbG9iYWwkMSA9IGFjdHVhbEdsb2JhbDtcblxuZnVuY3Rpb24gb2JzZXJ2YWJsZShvcHRzID0ge30pIHtcbiAgY29uc3QgT2JzZXJ2YWJsZSA9IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBAVE9ETyBjb25zaWRlciBkcm9wcGluZyBjaGVja2luZyBmb3IgYSBnbG9iYWwgT2JzZXJ2YWJsZSBzaW5jZSBpdCdzIG5vdCBvbiBhIHN0YW5kYXJkcyB0cmFja1xuICAgIG9wdHMuaW1wbGVtZW50YXRpb24gfHwgZ2xvYmFsJDEuT2JzZXJ2YWJsZVxuICApO1xuICBpZiAoIU9ic2VydmFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBPYnNlcnZhYmxlYCBpcyBub3QgYXZhaWxhYmxlIGluIGdsb2JhbCBzY29wZSwgYW5kIG5vIGltcGxlbWVudGF0aW9uIHdhcyBwYXNzZWRcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZSgoZXJyKSA9PiBvYnNlcnZlci5lcnJvcihlcnIpKTtcbiAgICAgIGNoYW5uZWxzLnByb2dyZXNzLnN1YnNjcmliZShcbiAgICAgICAgKGV2ZW50KSA9PiBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInByb2dyZXNzXCIgfSwgZXZlbnQpKVxuICAgICAgKTtcbiAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChPYmplY3QuYXNzaWduKHsgdHlwZTogXCJyZXNwb25zZVwiIH0sIHJlc3BvbnNlKSk7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgIHJldHVybiAoKSA9PiBjaGFubmVscy5hYm9ydC5wdWJsaXNoKCk7XG4gICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplcihzdGFnZSkge1xuICByZXR1cm4gKHByb2cpID0+ICh7XG4gICAgc3RhZ2UsXG4gICAgcGVyY2VudDogcHJvZy5wZXJjZW50YWdlLFxuICAgIHRvdGFsOiBwcm9nLmxlbmd0aCxcbiAgICBsb2FkZWQ6IHByb2cudHJhbnNmZXJyZWQsXG4gICAgbGVuZ3RoQ29tcHV0YWJsZTogIShwcm9nLmxlbmd0aCA9PT0gMCAmJiBwcm9nLnBlcmNlbnRhZ2UgPT09IDApXG4gIH0pO1xufVxuZnVuY3Rpb24gcHJvZ3Jlc3MoKSB7XG4gIHJldHVybiB7XG4gICAgb25IZWFkZXJzOiAocmVzcG9uc2UsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgX3Byb2dyZXNzID0gcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdCh7IHRpbWU6IDE2IH0pO1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gbm9ybWFsaXplcihcImRvd25sb2FkXCIpO1xuICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGNvbnRlbnRMZW5ndGggPyBOdW1iZXIoY29udGVudExlbmd0aCkgOiAwO1xuICAgICAgaWYgKCFpc05hTihsZW5ndGgpICYmIGxlbmd0aCA+IDApIHtcbiAgICAgICAgX3Byb2dyZXNzLnNldExlbmd0aChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgX3Byb2dyZXNzLm9uKFwicHJvZ3Jlc3NcIiwgKHByb2cpID0+IGV2dC5jb250ZXh0LmNoYW5uZWxzLnByb2dyZXNzLnB1Ymxpc2gobm9ybWFsaXplKHByb2cpKSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UucGlwZShfcHJvZ3Jlc3MpO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiAoZXZ0KSA9PiB7XG4gICAgICBpZiAoIWV2dC5wcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemUgPSBub3JtYWxpemVyKFwidXBsb2FkXCIpO1xuICAgICAgZXZ0LnByb2dyZXNzLm9uKFxuICAgICAgICBcInByb2dyZXNzXCIsXG4gICAgICAgIChwcm9nKSA9PiBldnQuY29udGV4dC5jaGFubmVscy5wcm9ncmVzcy5wdWJsaXNoKG5vcm1hbGl6ZShwcm9nKSlcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBwcm9taXNlID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBQcm9taXNlSW1wbGVtZW50YXRpb24gPSBvcHRpb25zLmltcGxlbWVudGF0aW9uIHx8IFByb21pc2U7XG4gIGlmICghUHJvbWlzZUltcGxlbWVudGF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYFByb21pc2VgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBQcm9taXNlSW1wbGVtZW50YXRpb24oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FuY2VsID0gY29udGV4dC5vcHRpb25zLmNhbmNlbFRva2VuO1xuICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICBjYW5jZWwucHJvbWlzZS50aGVuKChyZWFzb24pID0+IHtcbiAgICAgICAgICBjaGFubmVscy5hYm9ydC5wdWJsaXNoKHJlYXNvbik7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2hhbm5lbHMuZXJyb3Iuc3Vic2NyaWJlKHJlamVjdCk7XG4gICAgICBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUob3B0aW9ucy5vbmx5Qm9keSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pXG4gIH07XG59O1xuY2xhc3MgQ2FuY2VsIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMuX19DQU5DRUxfXyA9IHRydWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJDYW5jZWxcIi5jb25jYXQodGhpcy5tZXNzYWdlID8gXCI6IFwiLmNvbmNhdCh0aGlzLm1lc3NhZ2UpIDogXCJcIik7XG4gIH1cbn1cbmNvbnN0IF9DYW5jZWxUb2tlbiA9IGNsYXNzIF9DYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGV4ZWN1dG9yKChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodGhpcy5yZWFzb24pO1xuICAgIH0pO1xuICB9XG59O1xuX0NhbmNlbFRva2VuLnNvdXJjZSA9ICgpID0+IHtcbiAgbGV0IGNhbmNlbDtcbiAgY29uc3QgdG9rZW4gPSBuZXcgX0NhbmNlbFRva2VuKChjYW4pID0+IHtcbiAgICBjYW5jZWwgPSBjYW47XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuLFxuICAgIGNhbmNlbFxuICB9O1xufTtcbmxldCBDYW5jZWxUb2tlbiA9IF9DYW5jZWxUb2tlbjtcbmNvbnN0IGlzQ2FuY2VsID0gKHZhbHVlKSA9PiAhISh2YWx1ZSAmJiAodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9fQ0FOQ0VMX18pKTtcbnByb21pc2UuQ2FuY2VsID0gQ2FuY2VsO1xucHJvbWlzZS5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xucHJvbWlzZS5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuXG5mdW5jdGlvbiBwcm94eShfcHJveHkpIHtcbiAgaWYgKF9wcm94eSAhPT0gZmFsc2UgJiYgKCFfcHJveHkgfHwgIV9wcm94eS5ob3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IG1pZGRsZXdhcmUgdGFrZXMgYW4gb2JqZWN0IG9mIGhvc3QsIHBvcnQgYW5kIGF1dGggcHJvcGVydGllc1wiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4gT2JqZWN0LmFzc2lnbih7IHByb3h5OiBfcHJveHkgfSwgb3B0aW9ucylcbiAgfTtcbn1cblxudmFyIGRlZmF1bHRTaG91bGRSZXRyeSA9IChlcnIsIG51bSwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucy5tZXRob2QgIT09IFwiR0VUXCIgJiYgb3B0aW9ucy5tZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFsbG93ZWRfX2RlZmF1bHQuZGVmYXVsdChlcnIpO1xufTtcblxuY29uc3QgaXNTdHJlYW0gPSAoc3RyZWFtKSA9PiBzdHJlYW0gIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc3RyZWFtLnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbnZhciBzaGFyZWRSZXRyeSA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IG1heFJldHJpZXMgPSBvcHRzLm1heFJldHJpZXMgfHwgNTtcbiAgY29uc3QgcmV0cnlEZWxheSA9IG9wdHMucmV0cnlEZWxheSB8fCBnZXRSZXRyeURlbGF5O1xuICBjb25zdCBhbGxvd1JldHJ5ID0gb3B0cy5zaG91bGRSZXRyeTtcbiAgcmV0dXJuIHtcbiAgICBvbkVycm9yOiAoZXJyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8IG1heFJldHJpZXM7XG4gICAgICBjb25zdCBzaG91bGRSZXRyeSA9IG9wdGlvbnMuc2hvdWxkUmV0cnkgfHwgYWxsb3dSZXRyeTtcbiAgICAgIGNvbnN0IGF0dGVtcHROdW1iZXIgPSBvcHRpb25zLmF0dGVtcHROdW1iZXIgfHwgMDtcbiAgICAgIGlmIChpc1N0cmVhbShvcHRpb25zLmJvZHkpKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgfHwgYXR0ZW1wdE51bWJlciA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCB7XG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdE51bWJlciArIDEgfSlcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBjb250ZXh0LmNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChuZXdDb250ZXh0KSwgcmV0cnlEZWxheShhdHRlbXB0TnVtYmVyKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShhdHRlbXB0TnVtKSB7XG4gIHJldHVybiAxMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0TnVtKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG59XG5cbmNvbnN0IHJldHJ5ID0gKG9wdHMgPSB7fSkgPT4gc2hhcmVkUmV0cnkoeyBzaG91bGRSZXRyeTogZGVmYXVsdFNob3VsZFJldHJ5LCAuLi5vcHRzIH0pO1xucmV0cnkuc2hvdWxkUmV0cnkgPSBkZWZhdWx0U2hvdWxkUmV0cnk7XG5cbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBjb25zdCBuZXN0ID0gKG5hbWUsIF92YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gX3ZhbHVlIGluc3RhbmNlb2YgU2V0ID8gQXJyYXkuZnJvbShfdmFsdWUpIDogX3ZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHZhbHVlKSB7XG4gICAgICAgICAgbmVzdChcIlwiLmNvbmNhdChuYW1lLCBcIltcIikuY29uY2F0KGluZGV4LCBcIl1cIiksIHZhbHVlW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5LmFwcGVuZChcIlwiLmNvbmNhdChuYW1lLCBcIltdXCIpLCBcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCBvYmpdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBuZXN0KFwiXCIuY29uY2F0KG5hbWUsIFwiW1wiKS5jb25jYXQoa2V5LCBcIl1cIiksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5LmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgIG5lc3Qoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmxFbmNvZGVkKCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgY29uc3Qgc2hvdWxkU2VyaWFsaXplID0gIWlzU3RyZWFtICYmICFpc0J1ZmZlcihib2R5KSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYm9keSk7XG4gICAgICBpZiAoIXNob3VsZFNlcmlhbGl6ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGJvZHk6IGVuY29kZShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkS2VlcEFsaXZlKGFnZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZWVwQWxpdmUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtcyA9IGNvbmZpZy5tcyB8fCAxZTM7XG4gICAgY29uc3QgbWF4RnJlZSA9IGNvbmZpZy5tYXhGcmVlIHx8IDI1NjtcbiAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICBrZWVwQWxpdmVNc2VjczogbXMsXG4gICAgICBtYXhGcmVlU29ja2V0czogbWF4RnJlZVxuICAgIH07XG4gICAgcmV0dXJuIGFnZW50KGFnZW50T3B0aW9ucyk7XG4gIH07XG59XG5cbmNvbnN0IGtlZXBBbGl2ZSA9IGJ1aWxkS2VlcEFsaXZlKGFnZW50KTtcblxuZXhwb3J0cy5wcm9jZXNzT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnByb2Nlc3NPcHRpb25zO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbnMgPSBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci52YWxpZGF0ZU9wdGlvbnM7XG5leHBvcnRzLkNhbmNlbCA9IENhbmNlbDtcbmV4cG9ydHMuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmV4cG9ydHMuYWdlbnQgPSBhZ2VudDtcbmV4cG9ydHMuYmFzZSA9IGJhc2U7XG5leHBvcnRzLmRlYnVnID0gZGVidWc7XG5leHBvcnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuZXhwb3J0cy5odHRwRXJyb3JzID0gaHR0cEVycm9ycztcbmV4cG9ydHMuaW5qZWN0UmVzcG9uc2UgPSBpbmplY3RSZXNwb25zZTtcbmV4cG9ydHMuanNvblJlcXVlc3QgPSBqc29uUmVxdWVzdDtcbmV4cG9ydHMuanNvblJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuZXhwb3J0cy5rZWVwQWxpdmUgPSBrZWVwQWxpdmU7XG5leHBvcnRzLm10bHMgPSBtdGxzO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbmV4cG9ydHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmV4cG9ydHMucHJvbWlzZSA9IHByb21pc2U7XG5leHBvcnRzLnByb3h5ID0gcHJveHk7XG5leHBvcnRzLnJldHJ5ID0gcmV0cnk7XG5leHBvcnRzLnVybEVuY29kZWQgPSB1cmxFbmNvZGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRequester: () => (/* binding */ createRequester)\n/* harmony export */ });\n/* harmony import */ var _defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultOptionsValidator-N21NGwyb.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js\");\n\n\nconst middlewareReducer = (middleware) => function applyMiddleware(hook, defaultValue, ...args) {\n  const bailEarly = hook === \"onError\";\n  let value = defaultValue;\n  for (let i = 0; i < middleware[hook].length; i++) {\n    const handler = middleware[hook][i];\n    value = handler(value, ...args);\n    if (bailEarly && !value) {\n      break;\n    }\n  }\n  return value;\n};\n\nfunction createPubSub() {\n  const subscribers = /* @__PURE__ */ Object.create(null);\n  let nextId = 0;\n  function subscribe(subscriber) {\n    const id = nextId++;\n    subscribers[id] = subscriber;\n    return function unsubscribe() {\n      delete subscribers[id];\n    };\n  }\n  function publish(event) {\n    for (const id in subscribers) {\n      subscribers[id](event);\n    }\n  }\n  return {\n    publish,\n    subscribe\n  };\n}\n\nconst channelNames = [\n  \"request\",\n  \"response\",\n  \"progress\",\n  \"error\",\n  \"abort\"\n];\nconst middlehooks = [\n  \"processOptions\",\n  \"validateOptions\",\n  \"interceptRequest\",\n  \"finalizeOptions\",\n  \"onRequest\",\n  \"onResponse\",\n  \"onError\",\n  \"onReturn\",\n  \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n  const loadedMiddleware = [];\n  const middleware = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || [];\n      return ware;\n    },\n    {\n      processOptions: [_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_0__.processOptions],\n      validateOptions: [_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_0__.validateOptions]\n    }\n  );\n  function request(opts) {\n    const onResponse = (reqErr, res, ctx) => {\n      let error = reqErr;\n      let response = res;\n      if (!error) {\n        try {\n          response = applyMiddleware(\"onResponse\", res, ctx);\n        } catch (err) {\n          response = null;\n          error = err;\n        }\n      }\n      error = error && applyMiddleware(\"onError\", error, ctx);\n      if (error) {\n        channels.error.publish(error);\n      } else if (response) {\n        channels.response.publish(response);\n      }\n    };\n    const channels = channelNames.reduce((target, name) => {\n      target[name] = createPubSub();\n      return target;\n    }, {});\n    const applyMiddleware = middlewareReducer(middleware);\n    const options = applyMiddleware(\"processOptions\", opts);\n    applyMiddleware(\"validateOptions\", options);\n    const context = { options, channels, applyMiddleware };\n    let ongoingRequest;\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));\n    });\n    channels.abort.subscribe(() => {\n      unsubscribe();\n      if (ongoingRequest) {\n        ongoingRequest.abort();\n      }\n    });\n    const returnValue = applyMiddleware(\"onReturn\", channels, context);\n    if (returnValue === channels) {\n      channels.request.publish(context);\n    }\n    return returnValue;\n  }\n  request.use = function use(newMiddleware) {\n    if (!newMiddleware) {\n      throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    }\n    if (typeof newMiddleware === \"function\") {\n      throw new Error(\n        \"Tried to add middleware that was a function. It probably expects you to pass options to it.\"\n      );\n    }\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        \"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\"\n      );\n    }\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key]);\n      }\n    });\n    loadedMiddleware.push(newMiddleware);\n    return request;\n  };\n  request.clone = () => createRequester(loadedMiddleware, httpRequest);\n  initMiddleware.forEach(request.use);\n  return request;\n}\n\n\n//# sourceMappingURL=createRequester-46TmGIk5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9jcmVhdGVSZXF1ZXN0ZXItNDZUbUdJazUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixnRkFBYztBQUNyQyx3QkFBd0IsaUZBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhbHRvci8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9fY2h1bmtzL2NyZWF0ZVJlcXVlc3Rlci00NlRtR0lrNS5qcz9lNzViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByb2Nlc3NPcHRpb25zLCB2YWxpZGF0ZU9wdGlvbnMgfSBmcm9tICcuL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLU4yMU5Hd3liLmpzJztcblxuY29uc3QgbWlkZGxld2FyZVJlZHVjZXIgPSAobWlkZGxld2FyZSkgPT4gZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKGhvb2ssIGRlZmF1bHRWYWx1ZSwgLi4uYXJncykge1xuICBjb25zdCBiYWlsRWFybHkgPSBob29rID09PSBcIm9uRXJyb3JcIjtcbiAgbGV0IHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1pZGRsZXdhcmVbaG9va10ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBoYW5kbGVyID0gbWlkZGxld2FyZVtob29rXVtpXTtcbiAgICB2YWx1ZSA9IGhhbmRsZXIodmFsdWUsIC4uLmFyZ3MpO1xuICAgIGlmIChiYWlsRWFybHkgJiYgIXZhbHVlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbmV4dElkID0gMDtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICBjb25zdCBpZCA9IG5leHRJZCsrO1xuICAgIHN1YnNjcmliZXJzW2lkXSA9IHN1YnNjcmliZXI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgZGVsZXRlIHN1YnNjcmliZXJzW2lkXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyc1tpZF0oZXZlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHB1Ymxpc2gsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbmNvbnN0IGNoYW5uZWxOYW1lcyA9IFtcbiAgXCJyZXF1ZXN0XCIsXG4gIFwicmVzcG9uc2VcIixcbiAgXCJwcm9ncmVzc1wiLFxuICBcImVycm9yXCIsXG4gIFwiYWJvcnRcIlxuXTtcbmNvbnN0IG1pZGRsZWhvb2tzID0gW1xuICBcInByb2Nlc3NPcHRpb25zXCIsXG4gIFwidmFsaWRhdGVPcHRpb25zXCIsXG4gIFwiaW50ZXJjZXB0UmVxdWVzdFwiLFxuICBcImZpbmFsaXplT3B0aW9uc1wiLFxuICBcIm9uUmVxdWVzdFwiLFxuICBcIm9uUmVzcG9uc2VcIixcbiAgXCJvbkVycm9yXCIsXG4gIFwib25SZXR1cm5cIixcbiAgXCJvbkhlYWRlcnNcIlxuXTtcbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3Rlcihpbml0TWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpIHtcbiAgY29uc3QgbG9hZGVkTWlkZGxld2FyZSA9IFtdO1xuICBjb25zdCBtaWRkbGV3YXJlID0gbWlkZGxlaG9va3MucmVkdWNlKFxuICAgICh3YXJlLCBuYW1lKSA9PiB7XG4gICAgICB3YXJlW25hbWVdID0gd2FyZVtuYW1lXSB8fCBbXTtcbiAgICAgIHJldHVybiB3YXJlO1xuICAgIH0sXG4gICAge1xuICAgICAgcHJvY2Vzc09wdGlvbnM6IFtwcm9jZXNzT3B0aW9uc10sXG4gICAgICB2YWxpZGF0ZU9wdGlvbnM6IFt2YWxpZGF0ZU9wdGlvbnNdXG4gICAgfVxuICApO1xuICBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKHJlcUVyciwgcmVzLCBjdHgpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IHJlcUVycjtcbiAgICAgIGxldCByZXNwb25zZSA9IHJlcztcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IGFwcGx5TWlkZGxld2FyZShcIm9uUmVzcG9uc2VcIiwgcmVzLCBjdHgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVycm9yID0gZXJyb3IgJiYgYXBwbHlNaWRkbGV3YXJlKFwib25FcnJvclwiLCBlcnJvciwgY3R4KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgY2hhbm5lbHMucmVzcG9uc2UucHVibGlzaChyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjaGFubmVscyA9IGNoYW5uZWxOYW1lcy5yZWR1Y2UoKHRhcmdldCwgbmFtZSkgPT4ge1xuICAgICAgdGFyZ2V0W25hbWVdID0gY3JlYXRlUHViU3ViKCk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBhcHBseU1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlUmVkdWNlcihtaWRkbGV3YXJlKTtcbiAgICBjb25zdCBvcHRpb25zID0gYXBwbHlNaWRkbGV3YXJlKFwicHJvY2Vzc09wdGlvbnNcIiwgb3B0cyk7XG4gICAgYXBwbHlNaWRkbGV3YXJlKFwidmFsaWRhdGVPcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IG9wdGlvbnMsIGNoYW5uZWxzLCBhcHBseU1pZGRsZXdhcmUgfTtcbiAgICBsZXQgb25nb2luZ1JlcXVlc3Q7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBjaGFubmVscy5yZXF1ZXN0LnN1YnNjcmliZSgoY3R4KSA9PiB7XG4gICAgICBvbmdvaW5nUmVxdWVzdCA9IGh0dHBSZXF1ZXN0KGN0eCwgKGVyciwgcmVzKSA9PiBvblJlc3BvbnNlKGVyciwgcmVzLCBjdHgpKTtcbiAgICB9KTtcbiAgICBjaGFubmVscy5hYm9ydC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChvbmdvaW5nUmVxdWVzdCkge1xuICAgICAgICBvbmdvaW5nUmVxdWVzdC5hYm9ydCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXR1cm5cIiwgY2hhbm5lbHMsIGNvbnRleHQpO1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG4gIHJlcXVlc3QudXNlID0gZnVuY3Rpb24gdXNlKG5ld01pZGRsZXdhcmUpIHtcbiAgICBpZiAoIW5ld01pZGRsZXdhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgcmVzb2x2ZWQgdG8gZmFsc2V5IHZhbHVlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld01pZGRsZXdhcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgd2FzIGEgZnVuY3Rpb24uIEl0IHByb2JhYmx5IGV4cGVjdHMgeW91IHRvIHBhc3Mgb3B0aW9ucyB0byBpdC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG5ld01pZGRsZXdhcmUub25SZXR1cm4gJiYgbWlkZGxld2FyZS5vblJldHVybi5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVHJpZWQgdG8gYWRkIG5ldyBtaWRkbGV3YXJlIHdpdGggYG9uUmV0dXJuYCBoYW5kbGVyLCBidXQgYW5vdGhlciBoYW5kbGVyIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudFwiXG4gICAgICApO1xuICAgIH1cbiAgICBtaWRkbGVob29rcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChuZXdNaWRkbGV3YXJlW2tleV0pIHtcbiAgICAgICAgbWlkZGxld2FyZVtrZXldLnB1c2gobmV3TWlkZGxld2FyZVtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2FkZWRNaWRkbGV3YXJlLnB1c2gobmV3TWlkZGxld2FyZSk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH07XG4gIHJlcXVlc3QuY2xvbmUgPSAoKSA9PiBjcmVhdGVSZXF1ZXN0ZXIobG9hZGVkTWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpO1xuICBpbml0TWlkZGxld2FyZS5mb3JFYWNoKHJlcXVlc3QudXNlKTtcbiAgcmV0dXJuIHJlcXVlc3Q7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlcXVlc3RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlUmVxdWVzdGVyLTQ2VG1HSWs1LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js":
/*!******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processOptions: () => (/* binding */ processOptions),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions)\n/* harmony export */ });\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = { timeout: isReactNative ? 6e4 : 12e4 };\nconst processOptions = function processOptions2(opts) {\n  const options = {\n    ...defaultOptions,\n    ...typeof opts === \"string\" ? { url: opts } : opts\n  };\n  const { searchParams } = new URL(options.url, \"http://localhost\");\n  options.timeout = normalizeTimeout(options.timeout);\n  if (options.query) {\n    for (const [key, value] of Object.entries(options.query)) {\n      if (value !== void 0) {\n        if (Array.isArray(value)) {\n          for (const v of value) {\n            searchParams.append(key, v);\n          }\n        } else {\n          searchParams.append(key, value);\n        }\n      }\n    }\n  }\n  const [url] = options.url.split(\"?\");\n  const search = searchParams.toString();\n  if (search) {\n    options.url = \"\".concat(url, \"?\").concat(search);\n  }\n  options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n  return options;\n};\nfunction normalizeTimeout(time) {\n  if (time === false || time === 0) {\n    return false;\n  }\n  if (time.connect || time.socket) {\n    return time;\n  }\n  const delay = Number(time);\n  if (isNaN(delay)) {\n    return normalizeTimeout(defaultOptions.timeout);\n  }\n  return { connect: delay, socket: delay };\n}\n\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n  if (!validUrl.test(options.url)) {\n    throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n  }\n};\n\n\n//# sourceMappingURL=defaultOptionsValidator-N21NGwyb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1OMjFOR3d5Yi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFsdG9yLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItTjIxTkd3eWIuanM/MTk5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0geyB0aW1lb3V0OiBpc1JlYWN0TmF0aXZlID8gNmU0IDogMTJlNCB9O1xuY29uc3QgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uczIob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLnR5cGVvZiBvcHRzID09PSBcInN0cmluZ1wiID8geyB1cmw6IG9wdHMgfSA6IG9wdHNcbiAgfTtcbiAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwob3B0aW9ucy51cmwsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgb3B0aW9ucy50aW1lb3V0ID0gbm9ybWFsaXplVGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuICBpZiAob3B0aW9ucy5xdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBbdXJsXSA9IG9wdGlvbnMudXJsLnNwbGl0KFwiP1wiKTtcbiAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gIGlmIChzZWFyY2gpIHtcbiAgICBvcHRpb25zLnVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/XCIpLmNvbmNhdChzZWFyY2gpO1xuICB9XG4gIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5ib2R5ICYmICFvcHRpb25zLm1ldGhvZCA/IFwiUE9TVFwiIDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVvdXQodGltZSkge1xuICBpZiAodGltZSA9PT0gZmFsc2UgfHwgdGltZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGltZS5jb25uZWN0IHx8IHRpbWUuc29ja2V0KSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGltZSk7XG4gIGlmIChpc05hTihkZWxheSkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVGltZW91dChkZWZhdWx0T3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICByZXR1cm4geyBjb25uZWN0OiBkZWxheSwgc29ja2V0OiBkZWxheSB9O1xufVxuXG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuY29uc3QgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zMihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJy5jb25jYXQob3B0aW9ucy51cmwsICdcIiBpcyBub3QgYSB2YWxpZCBVUkwnKSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHByb2Nlc3NPcHRpb25zLCB2YWxpZGF0ZU9wdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLU4yMU5Hd3liLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/index.react-server.js":
/*!********************************************************!*\
  !*** ./node_modules/get-it/dist/index.react-server.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapter: () => (/* binding */ adapter),\n/* harmony export */   environment: () => (/* binding */ environment),\n/* harmony export */   getIt: () => (/* binding */ getIt)\n/* harmony export */ });\n/* harmony import */ var _chunks_createRequester_46TmGIk5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_chunks/createRequester-46TmGIk5.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js\");\n/* harmony import */ var parse_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse-headers */ \"(rsc)/./node_modules/parse-headers/parse-headers.js\");\n\n\n\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _method, _url, _resHeaders, _headers, _controller, _init, _useAbortSignal;\nclass FetchXhr {\n  constructor() {\n    /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n     */\n    this.readyState = 0;\n    this.responseType = \"\";\n    /**\n     * Private implementation details\n     */\n    __privateAdd(this, _method, void 0);\n    __privateAdd(this, _url, void 0);\n    __privateAdd(this, _resHeaders, void 0);\n    __privateAdd(this, _headers, {});\n    __privateAdd(this, _controller, void 0);\n    __privateAdd(this, _init, {});\n    __privateAdd(this, _useAbortSignal, void 0);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method, url, _async) {\n    __privateSet(this, _method, method);\n    __privateSet(this, _url, url);\n    __privateSet(this, _resHeaders, \"\");\n    this.readyState = 1;\n    this.onreadystatechange();\n    __privateSet(this, _controller, void 0);\n  }\n  abort() {\n    if (__privateGet(this, _controller)) {\n      __privateGet(this, _controller).abort();\n    }\n  }\n  getAllResponseHeaders() {\n    return __privateGet(this, _resHeaders);\n  }\n  setRequestHeader(name, value) {\n    __privateGet(this, _headers)[name] = value;\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init, useAbortSignal = true) {\n    __privateSet(this, _init, init);\n    __privateSet(this, _useAbortSignal, useAbortSignal);\n  }\n  send(body) {\n    const textBody = this.responseType !== \"arraybuffer\";\n    const options = {\n      ...__privateGet(this, _init),\n      method: __privateGet(this, _method),\n      headers: __privateGet(this, _headers),\n      body\n    };\n    if (typeof AbortController === \"function\" && __privateGet(this, _useAbortSignal)) {\n      __privateSet(this, _controller, new AbortController());\n      if (typeof EventTarget !== \"undefined\" && __privateGet(this, _controller).signal instanceof EventTarget) {\n        options.signal = __privateGet(this, _controller).signal;\n      }\n    }\n    if (typeof document !== \"undefined\") {\n      options.credentials = this.withCredentials ? \"include\" : \"omit\";\n    }\n    fetch(__privateGet(this, _url), options).then((res) => {\n      res.headers.forEach((value, key) => {\n        __privateSet(this, _resHeaders, __privateGet(this, _resHeaders) + \"\".concat(key, \": \").concat(value, \"\\r\\n\"));\n      });\n      this.status = res.status;\n      this.statusText = res.statusText;\n      this.readyState = 3;\n      return textBody ? res.text() : res.arrayBuffer();\n    }).then((resBody) => {\n      if (typeof resBody === \"string\") {\n        this.responseText = resBody;\n      } else {\n        this.response = resBody;\n      }\n      this.readyState = 4;\n      this.onreadystatechange();\n    }).catch((err) => {\n      var _a;\n      if (err.name === \"AbortError\") {\n        this.onabort();\n        return;\n      }\n      (_a = this.onerror) == null ? void 0 : _a.call(this, err);\n    });\n  }\n}\n_method = new WeakMap();\n_url = new WeakMap();\n_resHeaders = new WeakMap();\n_headers = new WeakMap();\n_controller = new WeakMap();\n_init = new WeakMap();\n_useAbortSignal = new WeakMap();\n\nconst adapter = typeof XMLHttpRequest === \"function\" ? \"xhr\" : \"fetch\";\nconst XmlHttpRequest = adapter === \"xhr\" ? XMLHttpRequest : FetchXhr;\nconst httpRequester = (context, callback) => {\n  var _a;\n  const opts = context.options;\n  const options = context.applyMiddleware(\"finalizeOptions\", opts);\n  const timers = {};\n  const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n    adapter,\n    context\n  });\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse);\n    const cancel = () => clearTimeout(cbTimer);\n    return { abort: cancel };\n  }\n  let xhr = new XmlHttpRequest();\n  if (xhr instanceof FetchXhr && typeof options.fetch === \"object\") {\n    xhr.setInit(options.fetch, (_a = options.useAbortSignal) != null ? _a : true);\n  }\n  const headers = options.headers;\n  const delays = options.timeout;\n  let aborted = false;\n  let loaded = false;\n  let timedOut = false;\n  xhr.onerror = (event) => {\n    onError(\n      new Error(\n        \"Request error while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")\n      )\n    );\n  };\n  xhr.ontimeout = (event) => {\n    onError(\n      new Error(\n        \"Request timeout while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")\n      )\n    );\n  };\n  xhr.onabort = () => {\n    stopTimers(true);\n    aborted = true;\n  };\n  xhr.onreadystatechange = () => {\n    resetTimers();\n    if (aborted || xhr.readyState !== 4) {\n      return;\n    }\n    if (xhr.status === 0) {\n      return;\n    }\n    onLoad();\n  };\n  xhr.open(\n    options.method,\n    options.url,\n    true\n    // Always async\n  );\n  xhr.withCredentials = !!options.withCredentials;\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  }\n  if (options.rawBody) {\n    xhr.responseType = \"arraybuffer\";\n  }\n  context.applyMiddleware(\"onRequest\", { options, adapter, request: xhr, context });\n  xhr.send(options.body || null);\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest(\"ETIMEDOUT\"), delays.connect);\n  }\n  return { abort };\n  function abort() {\n    aborted = true;\n    if (xhr) {\n      xhr.abort();\n    }\n  }\n  function timeoutRequest(code) {\n    timedOut = true;\n    xhr.abort();\n    const error = new Error(\n      code === \"ESOCKETTIMEDOUT\" ? \"Socket timed out on request to \".concat(options.url) : \"Connection timed out on request to \".concat(options.url)\n    );\n    error.code = code;\n    context.channels.error.publish(error);\n  }\n  function resetTimers() {\n    if (!delays) {\n      return;\n    }\n    stopTimers();\n    timers.socket = setTimeout(() => timeoutRequest(\"ESOCKETTIMEDOUT\"), delays.socket);\n  }\n  function stopTimers(force) {\n    if (force || aborted || xhr.readyState >= 2 && timers.connect) {\n      clearTimeout(timers.connect);\n    }\n    if (timers.socket) {\n      clearTimeout(timers.socket);\n    }\n  }\n  function onError(error) {\n    if (loaded) {\n      return;\n    }\n    stopTimers(true);\n    loaded = true;\n    xhr = null;\n    const err = error || new Error(\"Network error while attempting to reach \".concat(options.url));\n    err.isNetworkError = true;\n    err.request = options;\n    callback(err);\n  }\n  function reduceResponse() {\n    return {\n      body: xhr.response || (xhr.responseType === \"\" || xhr.responseType === \"text\" ? xhr.responseText : \"\"),\n      url: options.url,\n      method: options.method,\n      headers: parse_headers__WEBPACK_IMPORTED_MODULE_0__(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status,\n      statusMessage: xhr.statusText\n    };\n  }\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return;\n    }\n    if (xhr.status === 0) {\n      onError(new Error(\"Unknown XHR error\"));\n      return;\n    }\n    stopTimers();\n    loaded = true;\n    callback(null, reduceResponse());\n  }\n};\n\nconst getIt = (initMiddleware = [], httpRequest = httpRequester) => (0,_chunks_createRequester_46TmGIk5_js__WEBPACK_IMPORTED_MODULE_1__.createRequester)(initMiddleware, httpRequest);\n\nconst environment = \"react-server\";\n\n\n//# sourceMappingURL=index.react-server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXgucmVhY3Qtc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdFO0FBQy9COztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5Q0FBeUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRUFBb0Usb0ZBQWU7O0FBRW5GOztBQUV1QztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWx0b3IvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXgucmVhY3Qtc2VydmVyLmpzPzYwYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUmVxdWVzdGVyIH0gZnJvbSAnLi9fY2h1bmtzL2NyZWF0ZVJlcXVlc3Rlci00NlRtR0lrNS5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJ3BhcnNlLWhlYWRlcnMnO1xuXG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfbWV0aG9kLCBfdXJsLCBfcmVzSGVhZGVycywgX2hlYWRlcnMsIF9jb250cm9sbGVyLCBfaW5pdCwgX3VzZUFib3J0U2lnbmFsO1xuY2xhc3MgRmV0Y2hYaHIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvcmVhZHlTdGF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDA7XG4gICAgdGhpcy5yZXNwb25zZVR5cGUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaW1wbGVtZW50YXRpb24gZGV0YWlsc1xuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWV0aG9kLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXJsLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcmVzSGVhZGVycywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hlYWRlcnMsIHt9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NvbnRyb2xsZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9pbml0LCB7fSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91c2VBYm9ydFNpZ25hbCwgdm9pZCAwKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzIC0tIF9hc3luYyBpcyBvbmx5IGRlY2xhcmVkIGZvciB0eXBpbmdzIGNvbXBhdGliaWxpdHlcbiAgb3BlbihtZXRob2QsIHVybCwgX2FzeW5jKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tZXRob2QsIG1ldGhvZCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIHVybCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZXNIZWFkZXJzLCBcIlwiKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAxO1xuICAgIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb250cm9sbGVyLCB2b2lkIDApO1xuICB9XG4gIGFib3J0KCkge1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRyb2xsZXIpKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRyb2xsZXIpLmFib3J0KCk7XG4gICAgfVxuICB9XG4gIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9yZXNIZWFkZXJzKTtcbiAgfVxuICBzZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9oZWFkZXJzKVtuYW1lXSA9IHZhbHVlO1xuICB9XG4gIC8vIEFsbG93IHNldHRpbmcgZXh0cmEgZmV0Y2ggaW5pdCBvcHRpb25zLCBuZWVkZWQgZm9yIHJ1bnRpbWVzIHN1Y2ggYXMgVmVyY2VsIEVkZ2UgdG8gc2V0IGBjYWNoZWAgYW5kIG90aGVyIG9wdGlvbnMgaW4gUmVhY3QgU2VydmVyIENvbXBvbmVudHNcbiAgc2V0SW5pdChpbml0LCB1c2VBYm9ydFNpZ25hbCA9IHRydWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2luaXQsIGluaXQpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdXNlQWJvcnRTaWduYWwsIHVzZUFib3J0U2lnbmFsKTtcbiAgfVxuICBzZW5kKGJvZHkpIHtcbiAgICBjb25zdCB0ZXh0Qm9keSA9IHRoaXMucmVzcG9uc2VUeXBlICE9PSBcImFycmF5YnVmZmVyXCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLl9fcHJpdmF0ZUdldCh0aGlzLCBfaW5pdCksXG4gICAgICBtZXRob2Q6IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWV0aG9kKSxcbiAgICAgIGhlYWRlcnM6IF9fcHJpdmF0ZUdldCh0aGlzLCBfaGVhZGVycyksXG4gICAgICBib2R5XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gXCJmdW5jdGlvblwiICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXNlQWJvcnRTaWduYWwpKSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRyb2xsZXIsIG5ldyBBYm9ydENvbnRyb2xsZXIoKSk7XG4gICAgICBpZiAodHlwZW9mIEV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikuc2lnbmFsIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRyb2xsZXIpLnNpZ25hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy5jcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcIm9taXRcIjtcbiAgICB9XG4gICAgZmV0Y2goX19wcml2YXRlR2V0KHRoaXMsIF91cmwpLCBvcHRpb25zKS50aGVuKChyZXMpID0+IHtcbiAgICAgIHJlcy5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZXNIZWFkZXJzLCBfX3ByaXZhdGVHZXQodGhpcywgX3Jlc0hlYWRlcnMpICsgXCJcIi5jb25jYXQoa2V5LCBcIjogXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXHJcXG5cIikpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICB0aGlzLnN0YXR1c1RleHQgPSByZXMuc3RhdHVzVGV4dDtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IDM7XG4gICAgICByZXR1cm4gdGV4dEJvZHkgPyByZXMudGV4dCgpIDogcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgfSkudGhlbigocmVzQm9keSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZXNCb2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gcmVzQm9keTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNCb2R5O1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gNDtcbiAgICAgIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aGlzLm9uYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgKF9hID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH0pO1xuICB9XG59XG5fbWV0aG9kID0gbmV3IFdlYWtNYXAoKTtcbl91cmwgPSBuZXcgV2Vha01hcCgpO1xuX3Jlc0hlYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuX2hlYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuX2NvbnRyb2xsZXIgPSBuZXcgV2Vha01hcCgpO1xuX2luaXQgPSBuZXcgV2Vha01hcCgpO1xuX3VzZUFib3J0U2lnbmFsID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgYWRhcHRlciA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiID8gXCJ4aHJcIiA6IFwiZmV0Y2hcIjtcbmNvbnN0IFhtbEh0dHBSZXF1ZXN0ID0gYWRhcHRlciA9PT0gXCJ4aHJcIiA/IFhNTEh0dHBSZXF1ZXN0IDogRmV0Y2hYaHI7XG5jb25zdCBodHRwUmVxdWVzdGVyID0gKGNvbnRleHQsIGNhbGxiYWNrKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3Qgb3B0cyA9IGNvbnRleHQub3B0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiZmluYWxpemVPcHRpb25zXCIsIG9wdHMpO1xuICBjb25zdCB0aW1lcnMgPSB7fTtcbiAgY29uc3QgaW5qZWN0ZWRSZXNwb25zZSA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICBhZGFwdGVyLFxuICAgIGNvbnRleHRcbiAgfSk7XG4gIGlmIChpbmplY3RlZFJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2JUaW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDAsIG51bGwsIGluamVjdGVkUmVzcG9uc2UpO1xuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IGNsZWFyVGltZW91dChjYlRpbWVyKTtcbiAgICByZXR1cm4geyBhYm9ydDogY2FuY2VsIH07XG4gIH1cbiAgbGV0IHhociA9IG5ldyBYbWxIdHRwUmVxdWVzdCgpO1xuICBpZiAoeGhyIGluc3RhbmNlb2YgRmV0Y2hYaHIgJiYgdHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICB4aHIuc2V0SW5pdChvcHRpb25zLmZldGNoLCAoX2EgPSBvcHRpb25zLnVzZUFib3J0U2lnbmFsKSAhPSBudWxsID8gX2EgOiB0cnVlKTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICBjb25zdCBkZWxheXMgPSBvcHRpb25zLnRpbWVvdXQ7XG4gIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgbGV0IHRpbWVkT3V0ID0gZmFsc2U7XG4gIHhoci5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgb25FcnJvcihcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgXCJSZXF1ZXN0IGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmVhY2ggXCIuY29uY2F0KG9wdGlvbnMudXJsKS5jb25jYXQoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA/IFwiKFwiLmNvbmNhdChldmVudC5sb2FkZWQsIFwiIG9mIFwiKS5jb25jYXQoZXZlbnQudG90YWwsIFwiIGJ5dGVzIHRyYW5zZmVycmVkKVwiKSA6IFwiXCIpXG4gICAgICApXG4gICAgKTtcbiAgfTtcbiAgeGhyLm9udGltZW91dCA9IChldmVudCkgPT4ge1xuICAgIG9uRXJyb3IoXG4gICAgICBuZXcgRXJyb3IoXG4gICAgICAgIFwiUmVxdWVzdCB0aW1lb3V0IHdoaWxlIGF0dGVtcHRpbmcgdG8gcmVhY2ggXCIuY29uY2F0KG9wdGlvbnMudXJsKS5jb25jYXQoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA/IFwiKFwiLmNvbmNhdChldmVudC5sb2FkZWQsIFwiIG9mIFwiKS5jb25jYXQoZXZlbnQudG90YWwsIFwiIGJ5dGVzIHRyYW5zZmVycmVkKVwiKSA6IFwiXCIpXG4gICAgICApXG4gICAgKTtcbiAgfTtcbiAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgc3RvcFRpbWVycyh0cnVlKTtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfTtcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICByZXNldFRpbWVycygpO1xuICAgIGlmIChhYm9ydGVkIHx8IHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uTG9hZCgpO1xuICB9O1xuICB4aHIub3BlbihcbiAgICBvcHRpb25zLm1ldGhvZCxcbiAgICBvcHRpb25zLnVybCxcbiAgICB0cnVlXG4gICAgLy8gQWx3YXlzIGFzeW5jXG4gICk7XG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xuICBpZiAoaGVhZGVycyAmJiB4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yYXdCb2R5KSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgfVxuICBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uUmVxdWVzdFwiLCB7IG9wdGlvbnMsIGFkYXB0ZXIsIHJlcXVlc3Q6IHhociwgY29udGV4dCB9KTtcbiAgeGhyLnNlbmQob3B0aW9ucy5ib2R5IHx8IG51bGwpO1xuICBpZiAoZGVsYXlzKSB7XG4gICAgdGltZXJzLmNvbm5lY3QgPSBzZXRUaW1lb3V0KCgpID0+IHRpbWVvdXRSZXF1ZXN0KFwiRVRJTUVET1VUXCIpLCBkZWxheXMuY29ubmVjdCk7XG4gIH1cbiAgcmV0dXJuIHsgYWJvcnQgfTtcbiAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gICAgaWYgKHhocikge1xuICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRpbWVvdXRSZXF1ZXN0KGNvZGUpIHtcbiAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgeGhyLmFib3J0KCk7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICBjb2RlID09PSBcIkVTT0NLRVRUSU1FRE9VVFwiID8gXCJTb2NrZXQgdGltZWQgb3V0IG9uIHJlcXVlc3QgdG8gXCIuY29uY2F0KG9wdGlvbnMudXJsKSA6IFwiQ29ubmVjdGlvbiB0aW1lZCBvdXQgb24gcmVxdWVzdCB0byBcIi5jb25jYXQob3B0aW9ucy51cmwpXG4gICAgKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICBjb250ZXh0LmNoYW5uZWxzLmVycm9yLnB1Ymxpc2goZXJyb3IpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0VGltZXJzKCkge1xuICAgIGlmICghZGVsYXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BUaW1lcnMoKTtcbiAgICB0aW1lcnMuc29ja2V0ID0gc2V0VGltZW91dCgoKSA9PiB0aW1lb3V0UmVxdWVzdChcIkVTT0NLRVRUSU1FRE9VVFwiKSwgZGVsYXlzLnNvY2tldCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcFRpbWVycyhmb3JjZSkge1xuICAgIGlmIChmb3JjZSB8fCBhYm9ydGVkIHx8IHhoci5yZWFkeVN0YXRlID49IDIgJiYgdGltZXJzLmNvbm5lY3QpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMuY29ubmVjdCk7XG4gICAgfVxuICAgIGlmICh0aW1lcnMuc29ja2V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJzLnNvY2tldCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAobG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BUaW1lcnModHJ1ZSk7XG4gICAgbG9hZGVkID0gdHJ1ZTtcbiAgICB4aHIgPSBudWxsO1xuICAgIGNvbnN0IGVyciA9IGVycm9yIHx8IG5ldyBFcnJvcihcIk5ldHdvcmsgZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byByZWFjaCBcIi5jb25jYXQob3B0aW9ucy51cmwpKTtcbiAgICBlcnIuaXNOZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgIGVyci5yZXF1ZXN0ID0gb3B0aW9ucztcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZHVjZVJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBib2R5OiB4aHIucmVzcG9uc2UgfHwgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJ0ZXh0XCIgPyB4aHIucmVzcG9uc2VUZXh0IDogXCJcIiksXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLFxuICAgICAgc3RhdHVzQ29kZTogeGhyLnN0YXR1cyxcbiAgICAgIHN0YXR1c01lc3NhZ2U6IHhoci5zdGF0dXNUZXh0XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgaWYgKGFib3J0ZWQgfHwgbG9hZGVkIHx8IHRpbWVkT3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlVua25vd24gWEhSIGVycm9yXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcFRpbWVycygpO1xuICAgIGxvYWRlZCA9IHRydWU7XG4gICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UoKSk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEl0ID0gKGluaXRNaWRkbGV3YXJlID0gW10sIGh0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3RlcikgPT4gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCk7XG5cbmNvbnN0IGVudmlyb25tZW50ID0gXCJyZWFjdC1zZXJ2ZXJcIjtcblxuZXhwb3J0IHsgYWRhcHRlciwgZW52aXJvbm1lbnQsIGdldEl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5yZWFjdC1zZXJ2ZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/index.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/middleware.browser.js":
/*!********************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.browser.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cancel: () => (/* binding */ Cancel),\n/* harmony export */   CancelToken: () => (/* binding */ CancelToken),\n/* harmony export */   agent: () => (/* binding */ agent),\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   httpErrors: () => (/* binding */ httpErrors),\n/* harmony export */   injectResponse: () => (/* binding */ injectResponse),\n/* harmony export */   jsonRequest: () => (/* binding */ jsonRequest),\n/* harmony export */   jsonResponse: () => (/* binding */ jsonResponse),\n/* harmony export */   keepAlive: () => (/* binding */ keepAlive),\n/* harmony export */   mtls: () => (/* binding */ mtls),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   processOptions: () => (/* reexport safe */ _chunks_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_1__.processOptions),\n/* harmony export */   progress: () => (/* binding */ progress),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   urlEncoded: () => (/* binding */ urlEncoded),\n/* harmony export */   validateOptions: () => (/* reexport safe */ _chunks_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_1__.validateOptions)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var _chunks_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-N21NGwyb.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js\");\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n\n\n\n\nfunction agent(opts) {\n  return {};\n}\n\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n  const baseUri = baseUrl.replace(trailingSlash, \"\");\n  return {\n    processOptions: (options) => {\n      if (/^https?:\\/\\//i.test(options.url)) {\n        return options;\n      }\n      const url = [baseUri, options.url.replace(leadingSlash, \"\")].join(\"/\");\n      return Object.assign({}, options, { url });\n    }\n  };\n}\n\nconst SENSITIVE_HEADERS = [\"cookie\", \"authorization\"];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted) => {\n  const target = {};\n  for (const key in source) {\n    if (hasOwn.call(source, key)) {\n      target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n    }\n  }\n  return target;\n};\nfunction debug(opts = {}) {\n  const verbose = opts.verbose;\n  const namespace = opts.namespace || \"get-it\";\n  const defaultLogger = debug__WEBPACK_IMPORTED_MODULE_0__(namespace);\n  const log = opts.log || defaultLogger;\n  const shortCircuit = log === defaultLogger && !debug__WEBPACK_IMPORTED_MODULE_0__.enabled(namespace);\n  let requestId = 0;\n  return {\n    processOptions: (options) => {\n      options.debug = log;\n      options.requestId = options.requestId || ++requestId;\n      return options;\n    },\n    onRequest: (event) => {\n      if (shortCircuit || !event) {\n        return event;\n      }\n      const options = event.options;\n      log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n      if (verbose && options.body && typeof options.body === \"string\") {\n        log(\"[%s] Request body: %s\", options.requestId, options.body);\n      }\n      if (verbose && options.headers) {\n        const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n        log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n      }\n      return event;\n    },\n    onResponse: (res, context) => {\n      if (shortCircuit || !res) {\n        return res;\n      }\n      const reqId = context.options.requestId;\n      log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n      if (verbose && res.body) {\n        log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n      }\n      return res;\n    },\n    onError: (err, context) => {\n      const reqId = context.options.requestId;\n      if (!err) {\n        log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n        return err;\n      }\n      log(\"[%s] ERROR: %s\", reqId, err.message);\n      return err;\n    }\n  };\n}\nfunction stringifyBody(res) {\n  const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n  const isJson = contentType.indexOf(\"application/json\") !== -1;\n  return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n  try {\n    const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n    return JSON.stringify(parsed, null, 2);\n  } catch (err) {\n    return body;\n  }\n}\n\nfunction headers(_headers, opts = {}) {\n  return {\n    processOptions: (options) => {\n      const existing = options.headers || {};\n      options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n      return options;\n    }\n  };\n}\n\nclass HttpError extends Error {\n  constructor(res, ctx) {\n    super();\n    const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"\\u2026\") : res.url;\n    let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n    msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n    this.message = msg.trim();\n    this.response = res;\n    this.request = ctx.options;\n  }\n}\nfunction httpErrors() {\n  return {\n    onResponse: (res, ctx) => {\n      const isHttpError = res.statusCode >= 400;\n      if (!isHttpError) {\n        return res;\n      }\n      throw new HttpError(res, ctx);\n    }\n  };\n}\n\nfunction injectResponse(opts = {}) {\n  if (typeof opts.inject !== \"function\") {\n    throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n  }\n  const inject = function inject2(prevValue, event) {\n    const response = opts.inject(event, prevValue);\n    if (!response) {\n      return prevValue;\n    }\n    const options = event.context.options;\n    return {\n      body: \"\",\n      url: options.url,\n      method: options.method,\n      headers: {},\n      statusCode: 200,\n      statusMessage: \"OK\",\n      ...response\n    };\n  };\n  return { interceptRequest: inject };\n}\n\nconst isBuffer = typeof Buffer === \"undefined\" ? () => false : (obj) => Buffer.isBuffer(obj);\n\nconst serializeTypes = [\"boolean\", \"string\", \"number\"];\nfunction jsonRequest() {\n  return {\n    processOptions: (options) => {\n      const body = options.body;\n      if (!body) {\n        return options;\n      }\n      const isStream = typeof body.pipe === \"function\";\n      const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body));\n      if (!shouldSerialize) {\n        return options;\n      }\n      return Object.assign({}, options, {\n        body: JSON.stringify(options.body),\n        headers: Object.assign({}, options.headers, {\n          \"Content-Type\": \"application/json\"\n        })\n      });\n    }\n  };\n}\n\nfunction jsonResponse(opts) {\n  return {\n    onResponse: (response) => {\n      const contentType = response.headers[\"content-type\"] || \"\";\n      const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n      if (!response.body || !contentType || !shouldDecode) {\n        return response;\n      }\n      return Object.assign({}, response, { body: tryParse(response.body) });\n    },\n    processOptions: (options) => Object.assign({}, options, {\n      headers: Object.assign({ Accept: \"application/json\" }, options.headers)\n    })\n  };\n  function tryParse(body) {\n    try {\n      return JSON.parse(body);\n    } catch (err) {\n      err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n      throw err;\n    }\n  }\n}\n\nfunction isBrowserOptions(options) {\n  return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\n\nfunction mtls(config = {}) {\n  if (!config.ca) {\n    throw new Error('Required mtls option \"ca\" is missing');\n  }\n  if (!config.cert) {\n    throw new Error('Required mtls option \"cert\" is missing');\n  }\n  if (!config.key) {\n    throw new Error('Required mtls option \"key\" is missing');\n  }\n  return {\n    finalizeOptions: (options) => {\n      if (isBrowserOptions(options)) {\n        return options;\n      }\n      const mtlsOpts = {\n        cert: config.cert,\n        key: config.key,\n        ca: config.ca\n      };\n      return Object.assign({}, options, mtlsOpts);\n    }\n  };\n}\n\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n  actualGlobal = globalThis;\n} else if (typeof window !== \"undefined\") {\n  actualGlobal = window;\n} else if (typeof global !== \"undefined\") {\n  actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n  actualGlobal = self;\n}\nvar global$1 = actualGlobal;\n\nfunction observable(opts = {}) {\n  const Observable = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable\n  );\n  if (!Observable) {\n    throw new Error(\n      \"`Observable` is not available in global scope, and no implementation was passed\"\n    );\n  }\n  return {\n    onReturn: (channels, context) => new Observable((observer) => {\n      channels.error.subscribe((err) => observer.error(err));\n      channels.progress.subscribe(\n        (event) => observer.next(Object.assign({ type: \"progress\" }, event))\n      );\n      channels.response.subscribe((response) => {\n        observer.next(Object.assign({ type: \"response\" }, response));\n        observer.complete();\n      });\n      channels.request.publish(context);\n      return () => channels.abort.publish();\n    })\n  };\n}\n\nfunction progress() {\n  return {\n    onRequest: (evt) => {\n      if (evt.adapter !== \"xhr\") {\n        return;\n      }\n      const xhr = evt.request;\n      const context = evt.context;\n      if (\"upload\" in xhr && \"onprogress\" in xhr.upload) {\n        xhr.upload.onprogress = handleProgress(\"upload\");\n      }\n      if (\"onprogress\" in xhr) {\n        xhr.onprogress = handleProgress(\"download\");\n      }\n      function handleProgress(stage) {\n        return (event) => {\n          const percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;\n          context.channels.progress.publish({\n            stage,\n            percent,\n            total: event.total,\n            loaded: event.loaded,\n            lengthComputable: event.lengthComputable\n          });\n        };\n      }\n    }\n  };\n}\n\nconst promise = (options = {}) => {\n  const PromiseImplementation = options.implementation || Promise;\n  if (!PromiseImplementation) {\n    throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n  }\n  return {\n    onReturn: (channels, context) => new PromiseImplementation((resolve, reject) => {\n      const cancel = context.options.cancelToken;\n      if (cancel) {\n        cancel.promise.then((reason) => {\n          channels.abort.publish(reason);\n          reject(reason);\n        });\n      }\n      channels.error.subscribe(reject);\n      channels.response.subscribe((response) => {\n        resolve(options.onlyBody ? response.body : response);\n      });\n      setTimeout(() => {\n        try {\n          channels.request.publish(context);\n        } catch (err) {\n          reject(err);\n        }\n      }, 0);\n    })\n  };\n};\nclass Cancel {\n  constructor(message) {\n    this.__CANCEL__ = true;\n    this.message = message;\n  }\n  toString() {\n    return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n  }\n}\nconst _CancelToken = class _CancelToken {\n  constructor(executor) {\n    if (typeof executor !== \"function\") {\n      throw new TypeError(\"executor must be a function.\");\n    }\n    let resolvePromise = null;\n    this.promise = new Promise((resolve) => {\n      resolvePromise = resolve;\n    });\n    executor((message) => {\n      if (this.reason) {\n        return;\n      }\n      this.reason = new Cancel(message);\n      resolvePromise(this.reason);\n    });\n  }\n};\n_CancelToken.source = () => {\n  let cancel;\n  const token = new _CancelToken((can) => {\n    cancel = can;\n  });\n  return {\n    token,\n    cancel\n  };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value) => !!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\n\nfunction proxy(_proxy) {\n  if (_proxy !== false && (!_proxy || !_proxy.host)) {\n    throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n  }\n  return {\n    processOptions: (options) => Object.assign({ proxy: _proxy }, options)\n  };\n}\n\nvar defaultShouldRetry = (err, attempt, options) => {\n  if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n    return false;\n  }\n  return err.isNetworkError || false;\n};\n\nconst isStream = (stream) => stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts) => {\n  const maxRetries = opts.maxRetries || 5;\n  const retryDelay = opts.retryDelay || getRetryDelay;\n  const allowRetry = opts.shouldRetry;\n  return {\n    onError: (err, context) => {\n      const options = context.options;\n      const max = options.maxRetries || maxRetries;\n      const shouldRetry = options.shouldRetry || allowRetry;\n      const attemptNumber = options.attemptNumber || 0;\n      if (isStream(options.body)) {\n        return err;\n      }\n      if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n        return err;\n      }\n      const newContext = Object.assign({}, context, {\n        options: Object.assign({}, options, { attemptNumber: attemptNumber + 1 })\n      });\n      setTimeout(() => context.channels.request.publish(newContext), retryDelay(attemptNumber));\n      return null;\n    }\n  };\n};\nfunction getRetryDelay(attemptNum) {\n  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\n\nconst retry = (opts = {}) => sharedRetry({ shouldRetry: defaultShouldRetry, ...opts });\nretry.shouldRetry = defaultShouldRetry;\n\nfunction encode(data) {\n  const query = new URLSearchParams();\n  const nest = (name, _value) => {\n    const value = _value instanceof Set ? Array.from(_value) : _value;\n    if (Array.isArray(value)) {\n      if (value.length) {\n        for (const index in value) {\n          nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n        }\n      } else {\n        query.append(\"\".concat(name, \"[]\"), \"\");\n      }\n    } else if (typeof value === \"object\" && value !== null) {\n      for (const [key, obj] of Object.entries(value)) {\n        nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n      }\n    } else {\n      query.append(name, value);\n    }\n  };\n  for (const [key, value] of Object.entries(data)) {\n    nest(key, value);\n  }\n  return query.toString();\n}\nfunction urlEncoded() {\n  return {\n    processOptions: (options) => {\n      const body = options.body;\n      if (!body) {\n        return options;\n      }\n      const isStream = typeof body.pipe === \"function\";\n      const shouldSerialize = !isStream && !isBuffer(body) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body);\n      if (!shouldSerialize) {\n        return options;\n      }\n      return {\n        ...options,\n        body: encode(options.body),\n        headers: {\n          ...options.headers,\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n      };\n    }\n  };\n}\n\nfunction buildKeepAlive(agent) {\n  return function keepAlive(config = {}) {\n    const ms = config.ms || 1e3;\n    const maxFree = config.maxFree || 256;\n    const agentOptions = {\n      keepAlive: true,\n      keepAliveMsecs: ms,\n      maxFreeSockets: maxFree\n    };\n    return agent(agentOptions);\n  };\n}\n\nconst keepAlive = buildKeepAlive(agent);\n\n\n//# sourceMappingURL=middleware.browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ29FO0FBQ2hEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxLQUFLO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQU87QUFDL0I7QUFDQSxpREFBaUQsMENBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx3Q0FBd0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsOERBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFNkw7QUFDN0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFsdG9yLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L21pZGRsZXdhcmUuYnJvd3Nlci5qcz8yOTNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1Z0l0IGZyb20gJ2RlYnVnJztcbmV4cG9ydCB7IHByb2Nlc3NPcHRpb25zLCB2YWxpZGF0ZU9wdGlvbnMgfSBmcm9tICcuL19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItTjIxTkd3eWIuanMnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5cbmZ1bmN0aW9uIGFnZW50KG9wdHMpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5jb25zdCBsZWFkaW5nU2xhc2ggPSAvXlxcLy87XG5jb25zdCB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xuZnVuY3Rpb24gYmFzZShiYXNlVXJsKSB7XG4gIGNvbnN0IGJhc2VVcmkgPSBiYXNlVXJsLnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgXCJcIik7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCB1cmwgPSBbYmFzZVVyaSwgb3B0aW9ucy51cmwucmVwbGFjZShsZWFkaW5nU2xhc2gsIFwiXCIpXS5qb2luKFwiL1wiKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHVybCB9KTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IFNFTlNJVElWRV9IRUFERVJTID0gW1wiY29va2llXCIsIFwiYXV0aG9yaXphdGlvblwiXTtcbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCByZWRhY3RLZXlzID0gKHNvdXJjZSwgcmVkYWN0ZWQpID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd24uY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gcmVkYWN0ZWQuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPiAtMSA/IFwiPHJlZGFjdGVkPlwiIDogc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuZnVuY3Rpb24gZGVidWcob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHZlcmJvc2UgPSBvcHRzLnZlcmJvc2U7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IG9wdHMubmFtZXNwYWNlIHx8IFwiZ2V0LWl0XCI7XG4gIGNvbnN0IGRlZmF1bHRMb2dnZXIgPSBkZWJ1Z0l0KG5hbWVzcGFjZSk7XG4gIGNvbnN0IGxvZyA9IG9wdHMubG9nIHx8IGRlZmF1bHRMb2dnZXI7XG4gIGNvbnN0IHNob3J0Q2lyY3VpdCA9IGxvZyA9PT0gZGVmYXVsdExvZ2dlciAmJiAhZGVidWdJdC5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGxldCByZXF1ZXN0SWQgPSAwO1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucy5kZWJ1ZyA9IGxvZztcbiAgICAgIG9wdGlvbnMucmVxdWVzdElkID0gb3B0aW9ucy5yZXF1ZXN0SWQgfHwgKytyZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuICAgIG9uUmVxdWVzdDogKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc2hvcnRDaXJjdWl0IHx8ICFldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQub3B0aW9ucztcbiAgICAgIGxvZyhcIlslc10gSFRUUCAlcyAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgb3B0aW9ucy5tZXRob2QsIG9wdGlvbnMudXJsKTtcbiAgICAgIGlmICh2ZXJib3NlICYmIG9wdGlvbnMuYm9keSAmJiB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZyhcIlslc10gUmVxdWVzdCBib2R5OiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgb3B0aW9ucy5ib2R5KTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJib3NlICYmIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gb3B0cy5yZWRhY3RTZW5zaXRpdmVIZWFkZXJzID09PSBmYWxzZSA/IG9wdGlvbnMuaGVhZGVycyA6IHJlZGFjdEtleXMob3B0aW9ucy5oZWFkZXJzLCBTRU5TSVRJVkVfSEVBREVSUyk7XG4gICAgICAgIGxvZyhcIlslc10gUmVxdWVzdCBoZWFkZXJzOiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgSlNPTi5zdHJpbmdpZnkoaGVhZGVycywgbnVsbCwgMikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0sXG4gICAgb25SZXNwb25zZTogKHJlcywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhcmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBjb25zdCByZXFJZCA9IGNvbnRleHQub3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgICBsb2coXCJbJXNdIFJlc3BvbnNlIGNvZGU6ICVzICVzXCIsIHJlcUlkLCByZXMuc3RhdHVzQ29kZSwgcmVzLnN0YXR1c01lc3NhZ2UpO1xuICAgICAgaWYgKHZlcmJvc2UgJiYgcmVzLmJvZHkpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXNwb25zZSBib2R5OiAlc1wiLCByZXFJZCwgc3RyaW5naWZ5Qm9keShyZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBvbkVycm9yOiAoZXJyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCByZXFJZCA9IGNvbnRleHQub3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBsb2coXCJbJXNdIEVycm9yIGVuY291bnRlcmVkLCBidXQgaGFuZGxlZCBieSBhbiBlYXJsaWVyIG1pZGRsZXdhcmVcIiwgcmVxSWQpO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgbG9nKFwiWyVzXSBFUlJPUjogJXNcIiwgcmVxSWQsIGVyci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Qm9keShyZXMpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSAocmVzLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgaXNKc29uID0gY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xO1xuICByZXR1cm4gaXNKc29uID8gdHJ5Rm9ybWF0KHJlcy5ib2R5KSA6IHJlcy5ib2R5O1xufVxuZnVuY3Rpb24gdHJ5Rm9ybWF0KGJvZHkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSB0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWQsIG51bGwsIDIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoZWFkZXJzKF9oZWFkZXJzLCBvcHRzID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0cy5vdmVycmlkZSA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBfaGVhZGVycykgOiBPYmplY3QuYXNzaWduKHt9LCBfaGVhZGVycywgZXhpc3RpbmcpO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9O1xufVxuXG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcywgY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cnVuY2F0ZWRVcmwgPSByZXMudXJsLmxlbmd0aCA+IDQwMCA/IFwiXCIuY29uY2F0KHJlcy51cmwuc2xpY2UoMCwgMzk5KSwgXCJcXHUyMDI2XCIpIDogcmVzLnVybDtcbiAgICBsZXQgbXNnID0gXCJcIi5jb25jYXQocmVzLm1ldGhvZCwgXCItcmVxdWVzdCB0byBcIikuY29uY2F0KHRydW5jYXRlZFVybCwgXCIgcmVzdWx0ZWQgaW4gXCIpO1xuICAgIG1zZyArPSBcIkhUVFAgXCIuY29uY2F0KHJlcy5zdGF0dXNDb2RlLCBcIiBcIikuY29uY2F0KHJlcy5zdGF0dXNNZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2cudHJpbSgpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXM7XG4gICAgdGhpcy5yZXF1ZXN0ID0gY3R4Lm9wdGlvbnM7XG4gIH1cbn1cbmZ1bmN0aW9uIGh0dHBFcnJvcnMoKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXNwb25zZTogKHJlcywgY3R4KSA9PiB7XG4gICAgICBjb25zdCBpc0h0dHBFcnJvciA9IHJlcy5zdGF0dXNDb2RlID49IDQwMDtcbiAgICAgIGlmICghaXNIdHRwRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzLCBjdHgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0UmVzcG9uc2Uob3B0cyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygb3B0cy5pbmplY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBpbmplY3RSZXNwb25zZWAgbWlkZGxld2FyZSByZXF1aXJlcyBhIGBpbmplY3RgIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGNvbnN0IGluamVjdCA9IGZ1bmN0aW9uIGluamVjdDIocHJldlZhbHVlLCBldmVudCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gb3B0cy5pbmplY3QoZXZlbnQsIHByZXZWYWx1ZSk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LmNvbnRleHQub3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgYm9keTogXCJcIixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICBzdGF0dXNNZXNzYWdlOiBcIk9LXCIsXG4gICAgICAuLi5yZXNwb25zZVxuICAgIH07XG4gIH07XG4gIHJldHVybiB7IGludGVyY2VwdFJlcXVlc3Q6IGluamVjdCB9O1xufVxuXG5jb25zdCBpc0J1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIgPyAoKSA9PiBmYWxzZSA6IChvYmopID0+IEJ1ZmZlci5pc0J1ZmZlcihvYmopO1xuXG5jb25zdCBzZXJpYWxpemVUeXBlcyA9IFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIl07XG5mdW5jdGlvbiBqc29uUmVxdWVzdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N0cmVhbSA9IHR5cGVvZiBib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIGNvbnN0IHNob3VsZFNlcmlhbGl6ZSA9ICFpc1N0cmVhbSAmJiAhaXNCdWZmZXIoYm9keSkgJiYgKHNlcmlhbGl6ZVR5cGVzLmluZGV4T2YodHlwZW9mIGJvZHkpICE9PSAtMSB8fCBBcnJheS5pc0FycmF5KGJvZHkpIHx8IGlzUGxhaW5PYmplY3QoYm9keSkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBqc29uUmVzcG9uc2Uob3B0cykge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCI7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGUgPSBvcHRzICYmIG9wdHMuZm9yY2UgfHwgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xO1xuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5IHx8ICFjb250ZW50VHlwZSB8fCAhc2hvdWxkRGVjb2RlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSwgeyBib2R5OiB0cnlQYXJzZShyZXNwb25zZS5ib2R5KSB9KTtcbiAgICB9LFxuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pXG4gIH07XG4gIGZ1bmN0aW9uIHRyeVBhcnNlKGJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IFwiRmFpbGVkIHRvIHBhcnNlZCByZXNwb25zZSBib2R5IGFzIEpTT046IFwiLmNvbmNhdChlcnIubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCAmJiAhKFwicHJvdG9jb2xcIiBpbiBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbXRscyhjb25maWcgPSB7fSkge1xuICBpZiAoIWNvbmZpZy5jYSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJjYVwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWNvbmZpZy5jZXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNlcnRcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFjb25maWcua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImtleVwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbmFsaXplT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgbXRsc09wdHMgPSB7XG4gICAgICAgIGNlcnQ6IGNvbmZpZy5jZXJ0LFxuICAgICAgICBrZXk6IGNvbmZpZy5rZXksXG4gICAgICAgIGNhOiBjb25maWcuY2FcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgbXRsc09wdHMpO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGFjdHVhbEdsb2JhbCA9IHt9O1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IGdsb2JhbFRoaXM7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gc2VsZjtcbn1cbnZhciBnbG9iYWwkMSA9IGFjdHVhbEdsb2JhbDtcblxuZnVuY3Rpb24gb2JzZXJ2YWJsZShvcHRzID0ge30pIHtcbiAgY29uc3QgT2JzZXJ2YWJsZSA9IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBAVE9ETyBjb25zaWRlciBkcm9wcGluZyBjaGVja2luZyBmb3IgYSBnbG9iYWwgT2JzZXJ2YWJsZSBzaW5jZSBpdCdzIG5vdCBvbiBhIHN0YW5kYXJkcyB0cmFja1xuICAgIG9wdHMuaW1wbGVtZW50YXRpb24gfHwgZ2xvYmFsJDEuT2JzZXJ2YWJsZVxuICApO1xuICBpZiAoIU9ic2VydmFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBPYnNlcnZhYmxlYCBpcyBub3QgYXZhaWxhYmxlIGluIGdsb2JhbCBzY29wZSwgYW5kIG5vIGltcGxlbWVudGF0aW9uIHdhcyBwYXNzZWRcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZSgoZXJyKSA9PiBvYnNlcnZlci5lcnJvcihlcnIpKTtcbiAgICAgIGNoYW5uZWxzLnByb2dyZXNzLnN1YnNjcmliZShcbiAgICAgICAgKGV2ZW50KSA9PiBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInByb2dyZXNzXCIgfSwgZXZlbnQpKVxuICAgICAgKTtcbiAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChPYmplY3QuYXNzaWduKHsgdHlwZTogXCJyZXNwb25zZVwiIH0sIHJlc3BvbnNlKSk7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgIHJldHVybiAoKSA9PiBjaGFubmVscy5hYm9ydC5wdWJsaXNoKCk7XG4gICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvZ3Jlc3MoKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXF1ZXN0OiAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmFkYXB0ZXIgIT09IFwieGhyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeGhyID0gZXZ0LnJlcXVlc3Q7XG4gICAgICBjb25zdCBjb250ZXh0ID0gZXZ0LmNvbnRleHQ7XG4gICAgICBpZiAoXCJ1cGxvYWRcIiBpbiB4aHIgJiYgXCJvbnByb2dyZXNzXCIgaW4geGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcyhcInVwbG9hZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9ucHJvZ3Jlc3NcIiBpbiB4aHIpIHtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcyhcImRvd25sb2FkXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3Moc3RhZ2UpIHtcbiAgICAgICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBldmVudC5sZW5ndGhDb21wdXRhYmxlID8gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAxMDAgOiAtMTtcbiAgICAgICAgICBjb250ZXh0LmNoYW5uZWxzLnByb2dyZXNzLnB1Ymxpc2goe1xuICAgICAgICAgICAgc3RhZ2UsXG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgdG90YWw6IGV2ZW50LnRvdGFsLFxuICAgICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBldmVudC5sZW5ndGhDb21wdXRhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBwcm9taXNlID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBQcm9taXNlSW1wbGVtZW50YXRpb24gPSBvcHRpb25zLmltcGxlbWVudGF0aW9uIHx8IFByb21pc2U7XG4gIGlmICghUHJvbWlzZUltcGxlbWVudGF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYFByb21pc2VgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBQcm9taXNlSW1wbGVtZW50YXRpb24oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FuY2VsID0gY29udGV4dC5vcHRpb25zLmNhbmNlbFRva2VuO1xuICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICBjYW5jZWwucHJvbWlzZS50aGVuKChyZWFzb24pID0+IHtcbiAgICAgICAgICBjaGFubmVscy5hYm9ydC5wdWJsaXNoKHJlYXNvbik7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2hhbm5lbHMuZXJyb3Iuc3Vic2NyaWJlKHJlamVjdCk7XG4gICAgICBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUob3B0aW9ucy5vbmx5Qm9keSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pXG4gIH07XG59O1xuY2xhc3MgQ2FuY2VsIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMuX19DQU5DRUxfXyA9IHRydWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJDYW5jZWxcIi5jb25jYXQodGhpcy5tZXNzYWdlID8gXCI6IFwiLmNvbmNhdCh0aGlzLm1lc3NhZ2UpIDogXCJcIik7XG4gIH1cbn1cbmNvbnN0IF9DYW5jZWxUb2tlbiA9IGNsYXNzIF9DYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGV4ZWN1dG9yKChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodGhpcy5yZWFzb24pO1xuICAgIH0pO1xuICB9XG59O1xuX0NhbmNlbFRva2VuLnNvdXJjZSA9ICgpID0+IHtcbiAgbGV0IGNhbmNlbDtcbiAgY29uc3QgdG9rZW4gPSBuZXcgX0NhbmNlbFRva2VuKChjYW4pID0+IHtcbiAgICBjYW5jZWwgPSBjYW47XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuLFxuICAgIGNhbmNlbFxuICB9O1xufTtcbmxldCBDYW5jZWxUb2tlbiA9IF9DYW5jZWxUb2tlbjtcbmNvbnN0IGlzQ2FuY2VsID0gKHZhbHVlKSA9PiAhISh2YWx1ZSAmJiAodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9fQ0FOQ0VMX18pKTtcbnByb21pc2UuQ2FuY2VsID0gQ2FuY2VsO1xucHJvbWlzZS5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xucHJvbWlzZS5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuXG5mdW5jdGlvbiBwcm94eShfcHJveHkpIHtcbiAgaWYgKF9wcm94eSAhPT0gZmFsc2UgJiYgKCFfcHJveHkgfHwgIV9wcm94eS5ob3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IG1pZGRsZXdhcmUgdGFrZXMgYW4gb2JqZWN0IG9mIGhvc3QsIHBvcnQgYW5kIGF1dGggcHJvcGVydGllc1wiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4gT2JqZWN0LmFzc2lnbih7IHByb3h5OiBfcHJveHkgfSwgb3B0aW9ucylcbiAgfTtcbn1cblxudmFyIGRlZmF1bHRTaG91bGRSZXRyeSA9IChlcnIsIGF0dGVtcHQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMubWV0aG9kICE9PSBcIkdFVFwiICYmIG9wdGlvbnMubWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZXJyLmlzTmV0d29ya0Vycm9yIHx8IGZhbHNlO1xufTtcblxuY29uc3QgaXNTdHJlYW0gPSAoc3RyZWFtKSA9PiBzdHJlYW0gIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc3RyZWFtLnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbnZhciBzaGFyZWRSZXRyeSA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IG1heFJldHJpZXMgPSBvcHRzLm1heFJldHJpZXMgfHwgNTtcbiAgY29uc3QgcmV0cnlEZWxheSA9IG9wdHMucmV0cnlEZWxheSB8fCBnZXRSZXRyeURlbGF5O1xuICBjb25zdCBhbGxvd1JldHJ5ID0gb3B0cy5zaG91bGRSZXRyeTtcbiAgcmV0dXJuIHtcbiAgICBvbkVycm9yOiAoZXJyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8IG1heFJldHJpZXM7XG4gICAgICBjb25zdCBzaG91bGRSZXRyeSA9IG9wdGlvbnMuc2hvdWxkUmV0cnkgfHwgYWxsb3dSZXRyeTtcbiAgICAgIGNvbnN0IGF0dGVtcHROdW1iZXIgPSBvcHRpb25zLmF0dGVtcHROdW1iZXIgfHwgMDtcbiAgICAgIGlmIChpc1N0cmVhbShvcHRpb25zLmJvZHkpKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgfHwgYXR0ZW1wdE51bWJlciA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCB7XG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdE51bWJlciArIDEgfSlcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBjb250ZXh0LmNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChuZXdDb250ZXh0KSwgcmV0cnlEZWxheShhdHRlbXB0TnVtYmVyKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShhdHRlbXB0TnVtKSB7XG4gIHJldHVybiAxMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0TnVtKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG59XG5cbmNvbnN0IHJldHJ5ID0gKG9wdHMgPSB7fSkgPT4gc2hhcmVkUmV0cnkoeyBzaG91bGRSZXRyeTogZGVmYXVsdFNob3VsZFJldHJ5LCAuLi5vcHRzIH0pO1xucmV0cnkuc2hvdWxkUmV0cnkgPSBkZWZhdWx0U2hvdWxkUmV0cnk7XG5cbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBjb25zdCBuZXN0ID0gKG5hbWUsIF92YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gX3ZhbHVlIGluc3RhbmNlb2YgU2V0ID8gQXJyYXkuZnJvbShfdmFsdWUpIDogX3ZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHZhbHVlKSB7XG4gICAgICAgICAgbmVzdChcIlwiLmNvbmNhdChuYW1lLCBcIltcIikuY29uY2F0KGluZGV4LCBcIl1cIiksIHZhbHVlW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5LmFwcGVuZChcIlwiLmNvbmNhdChuYW1lLCBcIltdXCIpLCBcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCBvYmpdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBuZXN0KFwiXCIuY29uY2F0KG5hbWUsIFwiW1wiKS5jb25jYXQoa2V5LCBcIl1cIiksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5LmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgIG5lc3Qoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmxFbmNvZGVkKCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgY29uc3Qgc2hvdWxkU2VyaWFsaXplID0gIWlzU3RyZWFtICYmICFpc0J1ZmZlcihib2R5KSAmJiBpc1BsYWluT2JqZWN0KGJvZHkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBib2R5OiBlbmNvZGUob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEtlZXBBbGl2ZShhZ2VudCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2VlcEFsaXZlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgbXMgPSBjb25maWcubXMgfHwgMWUzO1xuICAgIGNvbnN0IG1heEZyZWUgPSBjb25maWcubWF4RnJlZSB8fCAyNTY7XG4gICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAga2VlcEFsaXZlTXNlY3M6IG1zLFxuICAgICAgbWF4RnJlZVNvY2tldHM6IG1heEZyZWVcbiAgICB9O1xuICAgIHJldHVybiBhZ2VudChhZ2VudE9wdGlvbnMpO1xuICB9O1xufVxuXG5jb25zdCBrZWVwQWxpdmUgPSBidWlsZEtlZXBBbGl2ZShhZ2VudCk7XG5cbmV4cG9ydCB7IENhbmNlbCwgQ2FuY2VsVG9rZW4sIGFnZW50LCBiYXNlLCBkZWJ1ZywgaGVhZGVycywgaHR0cEVycm9ycywgaW5qZWN0UmVzcG9uc2UsIGpzb25SZXF1ZXN0LCBqc29uUmVzcG9uc2UsIGtlZXBBbGl2ZSwgbXRscywgb2JzZXJ2YWJsZSwgcHJvZ3Jlc3MsIHByb21pc2UsIHByb3h5LCByZXRyeSwgdXJsRW5jb2RlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5icm93c2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/middleware.browser.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mendoza";
exports.ids = ["vendor-chunks/mendoza"];
exports.modules = {

/***/ "(ssr)/./node_modules/mendoza/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/mendoza/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   incremental: () => (/* binding */ incrementalPatcher)\n/* harmony export */ });\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst OPS = [\"Value\", \"Copy\", \"Blank\", \"ReturnIntoArray\", \"ReturnIntoObject\", \"ReturnIntoObjectSameKey\", \"PushField\", \"PushElement\", \"PushParent\", \"Pop\", \"PushFieldCopy\", \"PushFieldBlank\", \"PushElementCopy\", \"PushElementBlank\", \"ReturnIntoObjectPop\", \"ReturnIntoObjectSameKeyPop\", \"ReturnIntoArrayPop\", \"ObjectSetFieldValue\", \"ObjectCopyField\", \"ObjectDeleteField\", \"ArrayAppendValue\", \"ArrayAppendSlice\", \"StringAppendString\", \"StringAppendSlice\"];\nclass Patcher {\n  constructor(model, root, patch) {\n    __publicField$1(this, \"model\");\n    __publicField$1(this, \"root\");\n    __publicField$1(this, \"patch\");\n    __publicField$1(this, \"i\");\n    __publicField$1(this, \"inputStack\");\n    __publicField$1(this, \"outputStack\");\n    this.model = model;\n    this.root = root;\n    this.patch = patch;\n    this.i = 0;\n    this.inputStack = [];\n    this.outputStack = [];\n  }\n  read() {\n    return this.patch[this.i++];\n  }\n  process() {\n    this.inputStack.push({\n      value: this.root\n    });\n    this.outputStack.push({\n      value: this.root\n    });\n    for (; this.i < this.patch.length;) {\n      let opcode = this.read();\n      let op = OPS[opcode];\n      if (!op) throw new Error(\"Unknown opcode: \".concat(opcode));\n      let processor = \"process\".concat(op);\n      this[processor].apply(this);\n    }\n    let entry = this.outputStack.pop();\n    return this.finalizeOutput(entry);\n  }\n  inputEntry() {\n    return this.inputStack[this.inputStack.length - 1];\n  }\n  inputKey(entry, idx) {\n    if (!entry.keys) {\n      entry.keys = this.model.objectGetKeys(entry.value).sort();\n    }\n    return entry.keys[idx];\n  }\n  outputEntry() {\n    return this.outputStack[this.outputStack.length - 1];\n  }\n  outputArray() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyArray(entry.value);\n    }\n    return entry.writeValue;\n  }\n  outputObject() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyObject(entry.value);\n    }\n    return entry.writeValue;\n  }\n  outputString() {\n    let entry = this.outputEntry();\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyString(entry.value);\n    }\n    return entry.writeValue;\n  }\n  finalizeOutput(entry) {\n    if (entry.writeValue) {\n      return this.model.finalize(entry.writeValue);\n    } else {\n      return entry.value;\n    }\n  }\n  // Processors:\n  processValue() {\n    let value = this.model.wrap(this.read());\n    this.outputStack.push({\n      value\n    });\n  }\n  processCopy() {\n    let input = this.inputEntry();\n    this.outputStack.push({\n      value: input.value\n    });\n  }\n  processBlank() {\n    this.outputStack.push({\n      value: null\n    });\n  }\n  processReturnIntoArray() {\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    let arr = this.outputArray();\n    this.model.arrayAppendValue(arr, result);\n  }\n  processReturnIntoObject() {\n    let key = this.read();\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    result = this.model.markChanged(result);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, key, result);\n  }\n  processReturnIntoObjectSameKey() {\n    let input = this.inputEntry();\n    let entry = this.outputStack.pop();\n    let result = this.finalizeOutput(entry);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, input.key, result);\n  }\n  processPushField() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let key = this.inputKey(entry, idx);\n    let value = this.model.objectGetField(entry.value, key);\n    this.inputStack.push({\n      value,\n      key\n    });\n  }\n  processPushElement() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let value = this.model.arrayGetElement(entry.value, idx);\n    this.inputStack.push({\n      value\n    });\n  }\n  processPop() {\n    this.inputStack.pop();\n  }\n  processPushFieldCopy() {\n    this.processPushField();\n    this.processCopy();\n  }\n  processPushFieldBlank() {\n    this.processPushField();\n    this.processBlank();\n  }\n  processPushElementCopy() {\n    this.processPushElement();\n    this.processCopy();\n  }\n  processPushElementBlank() {\n    this.processPushElement();\n    this.processBlank();\n  }\n  processReturnIntoObjectPop() {\n    this.processReturnIntoObject();\n    this.processPop();\n  }\n  processReturnIntoObjectSameKeyPop() {\n    this.processReturnIntoObjectSameKey();\n    this.processPop();\n  }\n  processReturnIntoArrayPop() {\n    this.processReturnIntoArray();\n    this.processPop();\n  }\n  processObjectSetFieldValue() {\n    this.processValue();\n    this.processReturnIntoObject();\n  }\n  processObjectCopyField() {\n    this.processPushField();\n    this.processCopy();\n    this.processReturnIntoObjectSameKey();\n    this.processPop();\n  }\n  processObjectDeleteField() {\n    let idx = this.read();\n    let entry = this.inputEntry();\n    let key = this.inputKey(entry, idx);\n    let obj = this.outputObject();\n    this.model.objectDeleteField(obj, key);\n  }\n  processArrayAppendValue() {\n    let value = this.model.wrap(this.read());\n    let arr = this.outputArray();\n    this.model.arrayAppendValue(arr, value);\n  }\n  processArrayAppendSlice() {\n    let left = this.read();\n    let right = this.read();\n    let str = this.outputArray();\n    let val = this.inputEntry().value;\n    this.model.arrayAppendSlice(str, val, left, right);\n  }\n  processStringAppendString() {\n    let value = this.model.wrap(this.read());\n    let str = this.outputString();\n    this.model.stringAppendValue(str, value);\n  }\n  processStringAppendSlice() {\n    let left = this.read();\n    let right = this.read();\n    let str = this.outputString();\n    let val = this.inputEntry().value;\n    this.model.stringAppendSlice(str, val, left, right);\n  }\n}\nfunction utf8charSize(code) {\n  if (code >> 16) {\n    return 4;\n  } else if (code >> 11) {\n    return 3;\n  } else if (code >> 7) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\nfunction utf8stringSize(str) {\n  let b = 0;\n  for (let i = 0; i < str.length; i++) {\n    let code = str.codePointAt(i);\n    let size = utf8charSize(code);\n    if (size == 4) i++;\n    b += size;\n  }\n  return b;\n}\nfunction utf8resolveIndex(str, idx) {\n  let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let byteCount = start;\n  let ucsIdx = 0;\n  for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n    let code = str.codePointAt(ucsIdx);\n    let size = utf8charSize(code);\n    if (size === 4) ucsIdx++;\n    byteCount += size;\n  }\n  return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n  let len = Math.min(str.length, str2.length);\n  let b = 0;\n  for (let i = 0; i < len;) {\n    let aPoint = str.codePointAt(i);\n    let bPoint = str2.codePointAt(i);\n    if (aPoint !== bPoint) return b;\n    let size = utf8charSize(aPoint);\n    b += size;\n    i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nfunction commonSuffix(str, str2) {\n  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let len = Math.min(str.length, str2.length) - prefix;\n  let b = 0;\n  for (let i = 0; i < len;) {\n    let aPoint = str.codePointAt(str.length - 1 - i);\n    let bPoint = str2.codePointAt(str2.length - 1 - i);\n    if (aPoint !== bPoint) return b;\n    let size = utf8charSize(aPoint);\n    b += size;\n    i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass IncrementalModel {\n  constructor(meta) {\n    __publicField(this, \"meta\");\n    this.meta = meta;\n  }\n  wrap(data) {\n    return this.wrapWithMeta(data, this.meta, this.meta);\n  }\n  wrapWithMeta(data, startMeta) {\n    let endMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.meta;\n    return {\n      data,\n      startMeta,\n      endMeta\n    };\n  }\n  asObject(value) {\n    if (!value.content) {\n      let fields = {};\n      for (let [key, val] of Object.entries(value.data)) {\n        fields[key] = this.wrapWithMeta(val, value.startMeta);\n      }\n      value.content = {\n        type: \"object\",\n        fields\n      };\n    }\n    return value.content;\n  }\n  asArray(value) {\n    if (!value.content) {\n      let elements = value.data.map(item => this.wrapWithMeta(item, value.startMeta));\n      let metas = elements.map(() => this.meta);\n      value.content = {\n        type: \"array\",\n        elements,\n        metas\n      };\n    }\n    return value.content;\n  }\n  asString(value) {\n    if (!value.content) {\n      let str = value.data;\n      let part = {\n        value: str,\n        utf8size: utf8stringSize(str),\n        uses: [],\n        startMeta: value.startMeta,\n        endMeta: value.endMeta\n      };\n      value.content = this.stringFromParts([part]);\n    }\n    return value.content;\n  }\n  stringFromParts(parts) {\n    let str = {\n      type: \"string\",\n      parts\n    };\n    for (let part of parts) {\n      part.uses.push(str);\n    }\n    return str;\n  }\n  objectGetKeys(value) {\n    if (value.content) {\n      return Object.keys(value.content.fields);\n    } else {\n      return Object.keys(value.data);\n    }\n  }\n  objectGetField(value, key) {\n    let obj = this.asObject(value);\n    return obj.fields[key];\n  }\n  arrayGetElement(value, idx) {\n    let arr = this.asArray(value);\n    return arr.elements[idx];\n  }\n  finalize(content) {\n    this.updateEndMeta(content);\n    return {\n      content,\n      startMeta: this.meta,\n      endMeta: this.meta\n    };\n  }\n  markChanged(value) {\n    return this.wrap(unwrap(value));\n  }\n  updateEndMeta(content) {\n    if (content.type == \"string\") {\n      for (let part of content.parts) {\n        part.endMeta = this.meta;\n      }\n    } else {\n      if (content.type === \"array\") {\n        for (let val of content.elements) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content);\n          }\n          val.endMeta = this.meta;\n        }\n      } else {\n        for (let val of Object.values(content.fields)) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content);\n          }\n          val.endMeta = this.meta;\n        }\n      }\n    }\n  }\n  copyString(value) {\n    if (value) {\n      let other = this.asString(value);\n      return this.stringFromParts(other.parts.slice());\n    } else {\n      return {\n        type: \"string\",\n        parts: []\n      };\n    }\n  }\n  copyObject(value) {\n    let obj = {\n      type: \"object\",\n      fields: {}\n    };\n    if (value) {\n      let other = this.asObject(value);\n      Object.assign(obj.fields, other.fields);\n    }\n    return obj;\n  }\n  copyArray(value) {\n    let arr = value ? this.asArray(value) : null;\n    let elements = arr ? arr.elements : [];\n    let metas = arr ? arr.metas : [];\n    return {\n      type: \"array\",\n      elements,\n      metas\n    };\n  }\n  objectSetField(target, key, value) {\n    target.fields[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.fields[key];\n  }\n  arrayAppendValue(target, value) {\n    target.elements.push(value);\n    target.metas.push(this.meta);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    let arr = this.asArray(source);\n    let samePosition = arr.elements.length === left;\n    target.elements.push(...arr.elements.slice(left, right));\n    if (samePosition) {\n      target.metas.push(...arr.metas.slice(left, right));\n    } else {\n      for (let i = left; i < right; i++) {\n        target.metas.push(this.meta);\n      }\n    }\n  }\n  stringAppendValue(target, value) {\n    let str = this.asString(value);\n    for (let part of str.parts) {\n      this.stringAppendPart(target, part);\n    }\n  }\n  stringAppendPart(target, part) {\n    target.parts.push(part);\n    part.uses.push(target);\n  }\n  resolveStringPart(str, from, len) {\n    if (len === 0) return from;\n    for (let i = from; i < str.parts.length; i++) {\n      let part = str.parts[i];\n      if (len === part.utf8size) {\n        return i + 1;\n      }\n      if (len < part.utf8size) {\n        this.splitString(part, len);\n        return i + 1;\n      }\n      len -= part.utf8size;\n    }\n    throw new Error(\"splitting string out of bounds\");\n  }\n  splitString(part, idx) {\n    let leftValue;\n    let rightValue;\n    let leftSize = idx;\n    let rightSize = part.utf8size - leftSize;\n    if (part.utf8size !== part.value.length) {\n      let byteCount = 0;\n      for (idx = 0; byteCount < leftSize; idx++) {\n        let code = part.value.codePointAt(idx);\n        let size = utf8charSize(code);\n        if (size === 4) idx++;\n        byteCount += size;\n      }\n    }\n    leftValue = part.value.slice(0, idx);\n    rightValue = part.value.slice(idx);\n    let newPart = {\n      value: rightValue,\n      utf8size: rightSize,\n      uses: part.uses.slice(),\n      startMeta: part.startMeta,\n      endMeta: part.endMeta\n    };\n    part.value = leftValue;\n    part.utf8size = leftSize;\n    for (let use of part.uses) {\n      let ndx = use.parts.indexOf(part);\n      if (ndx === -1) throw new Error(\"bug: mismatch between string parts and use.\");\n      use.parts.splice(ndx + 1, 0, newPart);\n    }\n  }\n  stringAppendSlice(target, source, left, right) {\n    let str = this.asString(source);\n    let firstPart = this.resolveStringPart(str, 0, left);\n    let lastPart = this.resolveStringPart(str, firstPart, right - left);\n    for (let i = firstPart; i < lastPart; i++) {\n      let part = str.parts[i];\n      this.stringAppendPart(target, part);\n    }\n  }\n}\nfunction wrap(data, meta) {\n  return {\n    data,\n    startMeta: meta,\n    endMeta: meta\n  };\n}\nfunction unwrap(value) {\n  if (typeof value.data !== \"undefined\") return value.data;\n  let result;\n  let content = value.content;\n  switch (content.type) {\n    case \"string\":\n      result = content.parts.map(part => part.value).join(\"\");\n      break;\n    case \"array\":\n      result = content.elements.map(val => unwrap(val));\n      break;\n    case \"object\":\n      {\n        result = {};\n        for (let [key, val] of Object.entries(content.fields)) {\n          result[key] = unwrap(val);\n        }\n      }\n  }\n  value.data = result;\n  return result;\n}\nfunction getType(value) {\n  if (value.content) return value.content.type;\n  if (Array.isArray(value.data)) return \"array\";\n  if (value.data === null) return \"null\";\n  return typeof value.data;\n}\nfunction rebaseValue(left, right) {\n  let leftType = getType(left);\n  let rightType = getType(right);\n  if (leftType !== rightType) return right;\n  let leftModel = new IncrementalModel(left.endMeta);\n  let rightModel = new IncrementalModel(right.endMeta);\n  switch (leftType) {\n    case \"object\":\n      {\n        let leftObj = leftModel.asObject(left);\n        let rightObj = rightModel.asObject(right);\n        let identicalFieldCount = 0;\n        let leftFieldCount = Object.keys(leftObj.fields).length;\n        let rightFieldCount = Object.keys(rightObj.fields).length;\n        for (let [key, rightVal] of Object.entries(rightObj.fields)) {\n          let leftVal = leftObj.fields[key];\n          if (leftVal) {\n            rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n            if (rightObj.fields[key] === leftVal) {\n              identicalFieldCount++;\n            }\n          }\n        }\n        let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n        return isIdentical ? left : right;\n      }\n    case \"array\":\n      {\n        let leftArr = leftModel.asArray(left);\n        let rightArr = rightModel.asArray(right);\n        if (leftArr.elements.length !== rightArr.elements.length) {\n          break;\n        }\n        let numRebased = 0;\n        for (let i = 0; i < rightArr.elements.length; i++) {\n          rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n          if (rightArr.elements[i] !== leftArr.elements[i]) {\n            numRebased++;\n          }\n        }\n        return numRebased === 0 ? left : right;\n      }\n    case \"null\":\n    case \"boolean\":\n    case \"number\":\n      {\n        if (unwrap(left) === unwrap(right)) return left;\n        break;\n      }\n    case \"string\":\n      {\n        let leftRaw = unwrap(left);\n        let rightRaw = unwrap(right);\n        if (leftRaw === rightRaw) return left;\n        let result = rightModel.copyString(null);\n        let prefix = commonPrefix(leftRaw, rightRaw);\n        let suffix = commonSuffix(leftRaw, rightRaw, prefix);\n        let rightLen = utf8stringSize(rightRaw);\n        let leftLen = utf8stringSize(leftRaw);\n        if (0 < prefix) {\n          rightModel.stringAppendSlice(result, left, 0, prefix);\n        }\n        if (prefix < rightLen - suffix) {\n          rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n        }\n        if (leftLen - suffix < leftLen) {\n          rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n        }\n        let value = rightModel.finalize(result);\n        if (unwrap(value) !== rightRaw) throw new Error(\"incorrect string rebase\");\n        return value;\n      }\n  }\n  return right;\n}\nfunction applyPatch$1(left, patch, startMeta) {\n  let model = new IncrementalModel(startMeta);\n  let patcher = new Patcher(model, left, patch);\n  return patcher.process();\n}\nvar incrementalPatcher = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  applyPatch: applyPatch$1,\n  getType: getType,\n  rebaseValue: rebaseValue,\n  unwrap: unwrap,\n  wrap: wrap\n});\nclass SimpleModel {\n  wrap(data) {\n    return data;\n  }\n  finalize(b) {\n    if (Array.isArray(b)) {\n      return b;\n    } else {\n      return b.data;\n    }\n  }\n  markChanged(value) {\n    return value;\n  }\n  objectGetKeys(value) {\n    return Object.keys(value);\n  }\n  objectGetField(value, key) {\n    return value[key];\n  }\n  arrayGetElement(value, idx) {\n    return value[idx];\n  }\n  copyObject(value) {\n    let res = {\n      type: \"object\",\n      data: {}\n    };\n    if (value !== null) {\n      for (let [key, val] of Object.entries(value)) {\n        res.data[key] = val;\n      }\n    }\n    return res;\n  }\n  copyArray(value) {\n    if (value === null) return [];\n    return value.slice();\n  }\n  copyString(value) {\n    return {\n      type: \"string\",\n      data: value === null ? \"\" : value\n    };\n  }\n  objectSetField(target, key, value) {\n    target.data[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.data[key];\n  }\n  arrayAppendValue(target, value) {\n    target.push(value);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    target.push(...source.slice(left, right));\n  }\n  stringAppendSlice(target, source, left, right) {\n    const sourceString = source;\n    const leftPos = utf8resolveIndex(sourceString, left);\n    const rightPos = utf8resolveIndex(sourceString, right, leftPos);\n    target.data += sourceString.slice(leftPos, rightPos);\n  }\n  stringAppendValue(target, value) {\n    target.data += value;\n  }\n}\nfunction applyPatch(left, patch) {\n  let root = left;\n  let patcher = new Patcher(new SimpleModel(), root, patch);\n  return patcher.process();\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lEO0FBQ3pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhbHRvci8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2Rpc3QvaW5kZXguanM/YjM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IE9QUyA9IFtcIlZhbHVlXCIsIFwiQ29weVwiLCBcIkJsYW5rXCIsIFwiUmV0dXJuSW50b0FycmF5XCIsIFwiUmV0dXJuSW50b09iamVjdFwiLCBcIlJldHVybkludG9PYmplY3RTYW1lS2V5XCIsIFwiUHVzaEZpZWxkXCIsIFwiUHVzaEVsZW1lbnRcIiwgXCJQdXNoUGFyZW50XCIsIFwiUG9wXCIsIFwiUHVzaEZpZWxkQ29weVwiLCBcIlB1c2hGaWVsZEJsYW5rXCIsIFwiUHVzaEVsZW1lbnRDb3B5XCIsIFwiUHVzaEVsZW1lbnRCbGFua1wiLCBcIlJldHVybkludG9PYmplY3RQb3BcIiwgXCJSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcFwiLCBcIlJldHVybkludG9BcnJheVBvcFwiLCBcIk9iamVjdFNldEZpZWxkVmFsdWVcIiwgXCJPYmplY3RDb3B5RmllbGRcIiwgXCJPYmplY3REZWxldGVGaWVsZFwiLCBcIkFycmF5QXBwZW5kVmFsdWVcIiwgXCJBcnJheUFwcGVuZFNsaWNlXCIsIFwiU3RyaW5nQXBwZW5kU3RyaW5nXCIsIFwiU3RyaW5nQXBwZW5kU2xpY2VcIl07XG5jbGFzcyBQYXRjaGVyIHtcbiAgY29uc3RydWN0b3IobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibW9kZWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicm9vdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwYXRjaFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlucHV0U3RhY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwib3V0cHV0U3RhY2tcIik7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgIHRoaXMuaSA9IDA7XG4gICAgdGhpcy5pbnB1dFN0YWNrID0gW107XG4gICAgdGhpcy5vdXRwdXRTdGFjayA9IFtdO1xuICB9XG4gIHJlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0Y2hbdGhpcy5pKytdO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWU6IHRoaXMucm9vdFxuICAgIH0pO1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZTogdGhpcy5yb290XG4gICAgfSk7XG4gICAgZm9yICg7IHRoaXMuaSA8IHRoaXMucGF0Y2gubGVuZ3RoOykge1xuICAgICAgbGV0IG9wY29kZSA9IHRoaXMucmVhZCgpO1xuICAgICAgbGV0IG9wID0gT1BTW29wY29kZV07XG4gICAgICBpZiAoIW9wKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIuY29uY2F0KG9wY29kZSkpO1xuICAgICAgbGV0IHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiLmNvbmNhdChvcCk7XG4gICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICB9XG4gIGlucHV0RW50cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgaW5wdXRLZXkoZW50cnksIGlkeCkge1xuICAgIGlmICghZW50cnkua2V5cykge1xuICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkua2V5c1tpZHhdO1xuICB9XG4gIG91dHB1dEVudHJ5KCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0YWNrW3RoaXMub3V0cHV0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgb3V0cHV0QXJyYXkoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gIH1cbiAgb3V0cHV0T2JqZWN0KCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgfVxuICBvdXRwdXRTdHJpbmcoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICB9XG4gIGZpbmFsaXplT3V0cHV0KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmFsaXplKGVudHJ5LndyaXRlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICB9XG4gIC8vIFByb2Nlc3NvcnM6XG4gIHByb2Nlc3NWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NDb3B5KCkge1xuICAgIGxldCBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZTogaW5wdXQudmFsdWVcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzQmxhbmsoKSB7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9BcnJheSgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICBsZXQgYXJyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3QoKSB7XG4gICAgbGV0IGtleSA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcbiAgICBsZXQgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwga2V5LCByZXN1bHQpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpIHtcbiAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICBsZXQgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xuICB9XG4gIHByb2Nlc3NQdXNoRmllbGQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIGxldCBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBrZXlcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzUHVzaEVsZW1lbnQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwuYXJyYXlHZXRFbGVtZW50KGVudHJ5LnZhbHVlLCBpZHgpO1xuICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1BvcCgpIHtcbiAgICB0aGlzLmlucHV0U3RhY2sucG9wKCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZENvcHkoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICB9XG4gIHByb2Nlc3NQdXNoRmllbGRCbGFuaygpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcbiAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICB9XG4gIHByb2Nlc3NQdXNoRWxlbWVudENvcHkoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0UG9wKCkge1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3QoKTtcbiAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AoKSB7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wKCkge1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9BcnJheSgpO1xuICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICB9XG4gIHByb2Nlc3NPYmplY3RTZXRGaWVsZFZhbHVlKCkge1xuICAgIHRoaXMucHJvY2Vzc1ZhbHVlKCk7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICB9XG4gIHByb2Nlc3NPYmplY3RDb3B5RmllbGQoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5KCk7XG4gICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdERlbGV0ZUZpZWxkKCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICBsZXQga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KTtcbiAgICBsZXQgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdERlbGV0ZUZpZWxkKG9iaiwga2V5KTtcbiAgfVxuICBwcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgIGxldCBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICB9XG4gIHByb2Nlc3NBcnJheUFwcGVuZFNsaWNlKCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHN0ciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICBsZXQgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZygpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgIGxldCBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xuICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0FwcGVuZFNsaWNlKCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgbGV0IHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgfVxufVxuZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj4gMTYpIHtcbiAgICByZXR1cm4gNDtcbiAgfSBlbHNlIGlmIChjb2RlID4+IDExKSB7XG4gICAgcmV0dXJuIDM7XG4gIH0gZWxzZSBpZiAoY29kZSA+PiA3KSB7XG4gICAgcmV0dXJuIDI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHV0ZjhzdHJpbmdTaXplKHN0cikge1xuICBsZXQgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgaWYgKHNpemUgPT0gNCkgaSsrO1xuICAgIGIgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIHV0ZjhyZXNvbHZlSW5kZXgoc3RyLCBpZHgpIHtcbiAgbGV0IHN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBsZXQgYnl0ZUNvdW50ID0gc3RhcnQ7XG4gIGxldCB1Y3NJZHggPSAwO1xuICBmb3IgKHVjc0lkeCA9IHN0YXJ0OyBieXRlQ291bnQgPCBpZHg7IHVjc0lkeCsrKSB7XG4gICAgbGV0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQodWNzSWR4KTtcbiAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICBpZiAoc2l6ZSA9PT0gNCkgdWNzSWR4Kys7XG4gICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIHVjc0lkeDtcbn1cbmZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcbiAgbGV0IGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKTtcbiAgbGV0IGIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGxldCBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmIChhUG9pbnQgIT09IGJQb2ludCkgcmV0dXJuIGI7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICBiICs9IHNpemU7XG4gICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBjb21tb25TdWZmaXgoc3RyLCBzdHIyKSB7XG4gIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGxldCBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCkgLSBwcmVmaXg7XG4gIGxldCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgbGV0IGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChzdHIubGVuZ3RoIC0gMSAtIGkpO1xuICAgIGxldCBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KHN0cjIubGVuZ3RoIC0gMSAtIGkpO1xuICAgIGlmIChhUG9pbnQgIT09IGJQb2ludCkgcmV0dXJuIGI7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICBiICs9IHNpemU7XG4gICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgSW5jcmVtZW50YWxNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKG1ldGEpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWV0YVwiKTtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIHdyYXAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLndyYXBXaXRoTWV0YShkYXRhLCB0aGlzLm1ldGEsIHRoaXMubWV0YSk7XG4gIH1cbiAgd3JhcFdpdGhNZXRhKGRhdGEsIHN0YXJ0TWV0YSkge1xuICAgIGxldCBlbmRNZXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLm1ldGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBzdGFydE1ldGEsXG4gICAgICBlbmRNZXRhXG4gICAgfTtcbiAgfVxuICBhc09iamVjdCh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZS5kYXRhKSkge1xuICAgICAgICBmaWVsZHNba2V5XSA9IHRoaXMud3JhcFdpdGhNZXRhKHZhbCwgdmFsdWUuc3RhcnRNZXRhKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGZpZWxkc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gIH1cbiAgYXNBcnJheSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgbGV0IGVsZW1lbnRzID0gdmFsdWUuZGF0YS5tYXAoaXRlbSA9PiB0aGlzLndyYXBXaXRoTWV0YShpdGVtLCB2YWx1ZS5zdGFydE1ldGEpKTtcbiAgICAgIGxldCBtZXRhcyA9IGVsZW1lbnRzLm1hcCgoKSA9PiB0aGlzLm1ldGEpO1xuICAgICAgdmFsdWUuY29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgbWV0YXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIGFzU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgc3RyID0gdmFsdWUuZGF0YTtcbiAgICAgIGxldCBwYXJ0ID0ge1xuICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICB1dGY4c2l6ZTogdXRmOHN0cmluZ1NpemUoc3RyKSxcbiAgICAgICAgdXNlczogW10sXG4gICAgICAgIHN0YXJ0TWV0YTogdmFsdWUuc3RhcnRNZXRhLFxuICAgICAgICBlbmRNZXRhOiB2YWx1ZS5lbmRNZXRhXG4gICAgICB9O1xuICAgICAgdmFsdWUuY29udGVudCA9IHRoaXMuc3RyaW5nRnJvbVBhcnRzKFtwYXJ0XSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIHN0cmluZ0Zyb21QYXJ0cyhwYXJ0cykge1xuICAgIGxldCBzdHIgPSB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgcGFydHNcbiAgICB9O1xuICAgIGZvciAobGV0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHBhcnQudXNlcy5wdXNoKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgb2JqZWN0R2V0S2V5cyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuY29udGVudC5maWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG4gIG9iamVjdEdldEZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgcmV0dXJuIG9iai5maWVsZHNba2V5XTtcbiAgfVxuICBhcnJheUdldEVsZW1lbnQodmFsdWUsIGlkeCkge1xuICAgIGxldCBhcnIgPSB0aGlzLmFzQXJyYXkodmFsdWUpO1xuICAgIHJldHVybiBhcnIuZWxlbWVudHNbaWR4XTtcbiAgfVxuICBmaW5hbGl6ZShjb250ZW50KSB7XG4gICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50LFxuICAgICAgc3RhcnRNZXRhOiB0aGlzLm1ldGEsXG4gICAgICBlbmRNZXRhOiB0aGlzLm1ldGFcbiAgICB9O1xuICB9XG4gIG1hcmtDaGFuZ2VkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcCh1bndyYXAodmFsdWUpKTtcbiAgfVxuICB1cGRhdGVFbmRNZXRhKGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC50eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAobGV0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250ZW50LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBmb3IgKGxldCB2YWwgb2YgY29udGVudC5lbGVtZW50cykge1xuICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgdmFsIG9mIE9iamVjdC52YWx1ZXMoY29udGVudC5maWVsZHMpKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHlTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGxldCBvdGhlciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBwYXJ0czogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvcHlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgb2JqID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGZpZWxkczoge31cbiAgICB9O1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgbGV0IG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgICBPYmplY3QuYXNzaWduKG9iai5maWVsZHMsIG90aGVyLmZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29weUFycmF5KHZhbHVlKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGw7XG4gICAgbGV0IGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW107XG4gICAgbGV0IG1ldGFzID0gYXJyID8gYXJyLm1ldGFzIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWV0YXNcbiAgICB9O1xuICB9XG4gIG9iamVjdFNldEZpZWxkKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIHRhcmdldC5maWVsZHNba2V5XSA9IHZhbHVlO1xuICB9XG4gIG9iamVjdERlbGV0ZUZpZWxkKHRhcmdldCwga2V5KSB7XG4gICAgZGVsZXRlIHRhcmdldC5maWVsZHNba2V5XTtcbiAgfVxuICBhcnJheUFwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSk7XG4gICAgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcbiAgfVxuICBhcnJheUFwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGxldCBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKTtcbiAgICBsZXQgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcbiAgICB0YXJnZXQuZWxlbWVudHMucHVzaCguLi5hcnIuZWxlbWVudHMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICBpZiAoc2FtZVBvc2l0aW9uKSB7XG4gICAgICB0YXJnZXQubWV0YXMucHVzaCguLi5hcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0cmluZ0FwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICBsZXQgc3RyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgZm9yIChsZXQgcGFydCBvZiBzdHIucGFydHMpIHtcbiAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCkge1xuICAgIHRhcmdldC5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XG4gIH1cbiAgcmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCBmcm9tLCBsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKSByZXR1cm4gZnJvbTtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICBpZiAobGVuID09PSBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgIHRoaXMuc3BsaXRTdHJpbmcocGFydCwgbGVuKTtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgfVxuICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0dGluZyBzdHJpbmcgb3V0IG9mIGJvdW5kc1wiKTtcbiAgfVxuICBzcGxpdFN0cmluZyhwYXJ0LCBpZHgpIHtcbiAgICBsZXQgbGVmdFZhbHVlO1xuICAgIGxldCByaWdodFZhbHVlO1xuICAgIGxldCBsZWZ0U2l6ZSA9IGlkeDtcbiAgICBsZXQgcmlnaHRTaXplID0gcGFydC51dGY4c2l6ZSAtIGxlZnRTaXplO1xuICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgICBmb3IgKGlkeCA9IDA7IGJ5dGVDb3VudCA8IGxlZnRTaXplOyBpZHgrKykge1xuICAgICAgICBsZXQgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgICAgIGlmIChzaXplID09PSA0KSBpZHgrKztcbiAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIGxlZnRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICByaWdodFZhbHVlID0gcGFydC52YWx1ZS5zbGljZShpZHgpO1xuICAgIGxldCBuZXdQYXJ0ID0ge1xuICAgICAgdmFsdWU6IHJpZ2h0VmFsdWUsXG4gICAgICB1dGY4c2l6ZTogcmlnaHRTaXplLFxuICAgICAgdXNlczogcGFydC51c2VzLnNsaWNlKCksXG4gICAgICBzdGFydE1ldGE6IHBhcnQuc3RhcnRNZXRhLFxuICAgICAgZW5kTWV0YTogcGFydC5lbmRNZXRhXG4gICAgfTtcbiAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlO1xuICAgIHBhcnQudXRmOHNpemUgPSBsZWZ0U2l6ZTtcbiAgICBmb3IgKGxldCB1c2Ugb2YgcGFydC51c2VzKSB7XG4gICAgICBsZXQgbmR4ID0gdXNlLnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICBpZiAobmR4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiYnVnOiBtaXNtYXRjaCBiZXR3ZWVuIHN0cmluZyBwYXJ0cyBhbmQgdXNlLlwiKTtcbiAgICAgIHVzZS5wYXJ0cy5zcGxpY2UobmR4ICsgMSwgMCwgbmV3UGFydCk7XG4gICAgfVxuICB9XG4gIHN0cmluZ0FwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGxldCBzdHIgPSB0aGlzLmFzU3RyaW5nKHNvdXJjZSk7XG4gICAgbGV0IGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcbiAgICBsZXQgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xuICAgIGZvciAobGV0IGkgPSBmaXJzdFBhcnQ7IGkgPCBsYXN0UGFydDsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHN0ci5wYXJ0c1tpXTtcbiAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd3JhcChkYXRhLCBtZXRhKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBzdGFydE1ldGE6IG1ldGEsXG4gICAgZW5kTWV0YTogbWV0YVxuICB9O1xufVxuZnVuY3Rpb24gdW53cmFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBjb250ZW50ID0gdmFsdWUuY29udGVudDtcbiAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXN1bHQgPSBjb250ZW50LnBhcnRzLm1hcChwYXJ0ID0+IHBhcnQudmFsdWUpLmpvaW4oXCJcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJlc3VsdCA9IGNvbnRlbnQuZWxlbWVudHMubWFwKHZhbCA9PiB1bndyYXAodmFsKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnQuZmllbGRzKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICBpZiAodmFsdWUuY29udGVudCkgcmV0dXJuIHZhbHVlLmNvbnRlbnQudHlwZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHJldHVybiBcImFycmF5XCI7XG4gIGlmICh2YWx1ZS5kYXRhID09PSBudWxsKSByZXR1cm4gXCJudWxsXCI7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUuZGF0YTtcbn1cbmZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XG4gIGxldCBsZWZ0VHlwZSA9IGdldFR5cGUobGVmdCk7XG4gIGxldCByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcbiAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHJldHVybiByaWdodDtcbiAgbGV0IGxlZnRNb2RlbCA9IG5ldyBJbmNyZW1lbnRhbE1vZGVsKGxlZnQuZW5kTWV0YSk7XG4gIGxldCByaWdodE1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwocmlnaHQuZW5kTWV0YSk7XG4gIHN3aXRjaCAobGVmdFR5cGUpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICB7XG4gICAgICAgIGxldCBsZWZ0T2JqID0gbGVmdE1vZGVsLmFzT2JqZWN0KGxlZnQpO1xuICAgICAgICBsZXQgcmlnaHRPYmogPSByaWdodE1vZGVsLmFzT2JqZWN0KHJpZ2h0KTtcbiAgICAgICAgbGV0IGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xuICAgICAgICBsZXQgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICBsZXQgcmlnaHRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMocmlnaHRPYmouZmllbGRzKS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHJpZ2h0VmFsXSBvZiBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpKSB7XG4gICAgICAgICAgbGV0IGxlZnRWYWwgPSBsZWZ0T2JqLmZpZWxkc1trZXldO1xuICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XG4gICAgICAgICAgICByaWdodE9iai5maWVsZHNba2V5XSA9IHJlYmFzZVZhbHVlKGxlZnRWYWwsIHJpZ2h0VmFsKTtcbiAgICAgICAgICAgIGlmIChyaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCkge1xuICAgICAgICAgICAgICBpZGVudGljYWxGaWVsZENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpc0lkZW50aWNhbCA9IGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQ7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWNhbCA/IGxlZnQgOiByaWdodDtcbiAgICAgIH1cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGxlZnRBcnIgPSBsZWZ0TW9kZWwuYXNBcnJheShsZWZ0KTtcbiAgICAgICAgbGV0IHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcbiAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtUmViYXNlZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByaWdodEFyci5lbGVtZW50c1tpXSA9IHJlYmFzZVZhbHVlKGxlZnRBcnIuZWxlbWVudHNbaV0sIHJpZ2h0QXJyLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgIG51bVJlYmFzZWQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVJlYmFzZWQgPT09IDAgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICB9XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSkgcmV0dXJuIGxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGxlZnRSYXcgPSB1bndyYXAobGVmdCk7XG4gICAgICAgIGxldCByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XG4gICAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdykgcmV0dXJuIGxlZnQ7XG4gICAgICAgIGxldCByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XG4gICAgICAgIGxldCBwcmVmaXggPSBjb21tb25QcmVmaXgobGVmdFJhdywgcmlnaHRSYXcpO1xuICAgICAgICBsZXQgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xuICAgICAgICBsZXQgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XG4gICAgICAgIGxldCBsZWZ0TGVuID0gdXRmOHN0cmluZ1NpemUobGVmdFJhdyk7XG4gICAgICAgIGlmICgwIDwgcHJlZml4KSB7XG4gICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIDAsIHByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA8IHJpZ2h0TGVuIC0gc3VmZml4KSB7XG4gICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIHJpZ2h0LCBwcmVmaXgsIHJpZ2h0TGVuIC0gc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdExlbiAtIHN1ZmZpeCA8IGxlZnRMZW4pIHtcbiAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xuICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBzdHJpbmcgcmViYXNlXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHJpZ2h0O1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaCQxKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcbiAgbGV0IG1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwoc3RhcnRNZXRhKTtcbiAgbGV0IHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihtb2RlbCwgbGVmdCwgcGF0Y2gpO1xuICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XG59XG52YXIgaW5jcmVtZW50YWxQYXRjaGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFwcGx5UGF0Y2g6IGFwcGx5UGF0Y2gkMSxcbiAgZ2V0VHlwZTogZ2V0VHlwZSxcbiAgcmViYXNlVmFsdWU6IHJlYmFzZVZhbHVlLFxuICB1bndyYXA6IHVud3JhcCxcbiAgd3JhcDogd3JhcFxufSk7XG5jbGFzcyBTaW1wbGVNb2RlbCB7XG4gIHdyYXAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZpbmFsaXplKGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiLmRhdGE7XG4gICAgfVxuICB9XG4gIG1hcmtDaGFuZ2VkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIG9iamVjdEdldEtleXModmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICB9XG4gIG9iamVjdEdldEZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgfVxuICBhcnJheUdldEVsZW1lbnQodmFsdWUsIGlkeCkge1xuICAgIHJldHVybiB2YWx1ZVtpZHhdO1xuICB9XG4gIGNvcHlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIHJlcy5kYXRhW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgY29weUFycmF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH1cbiAgY29weVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZGF0YTogdmFsdWUgPT09IG51bGwgPyBcIlwiIDogdmFsdWVcbiAgICB9O1xuICB9XG4gIG9iamVjdFNldEZpZWxkKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBvYmplY3REZWxldGVGaWVsZCh0YXJnZXQsIGtleSkge1xuICAgIGRlbGV0ZSB0YXJnZXQuZGF0YVtrZXldO1xuICB9XG4gIGFycmF5QXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHRhcmdldC5wdXNoKHZhbHVlKTtcbiAgfVxuICBhcnJheUFwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIHRhcmdldC5wdXNoKC4uLnNvdXJjZS5zbGljZShsZWZ0LCByaWdodCkpO1xuICB9XG4gIHN0cmluZ0FwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHNvdXJjZVN0cmluZyA9IHNvdXJjZTtcbiAgICBjb25zdCBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIHJpZ2h0LCBsZWZ0UG9zKTtcbiAgICB0YXJnZXQuZGF0YSArPSBzb3VyY2VTdHJpbmcuc2xpY2UobGVmdFBvcywgcmlnaHRQb3MpO1xuICB9XG4gIHN0cmluZ0FwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xuICBsZXQgcm9vdCA9IGxlZnQ7XG4gIGxldCBwYXRjaGVyID0gbmV3IFBhdGNoZXIobmV3IFNpbXBsZU1vZGVsKCksIHJvb3QsIHBhdGNoKTtcbiAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxuZXhwb3J0IHsgYXBwbHlQYXRjaCwgaW5jcmVtZW50YWxQYXRjaGVyIGFzIGluY3JlbWVudGFsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mendoza/dist/index.js\n");

/***/ })

};
;